# Managing Branch Divergence on GPUs

## Overview

The most fundamental difference between GPUs and CPUs is the notion of _branch divergence_, which arises from the steplock of threads within warps. The steplock is part of what gives the GPU so many active parallel threads per joule, but also constrains the computational model. It has a crushing effect on GPU throughput, because it serialises execution (on weak cores): if threads within a warp disagree about which instructions to execute next, they have to take turns. In this lesson, we will encounter and try to resolve an example of rampant branch divergence.

The problem we will study is a simplification of a classic analytics problem of time series analysis (like [1], but without the [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform).) When people talk of "Big Data," they invariably mean some sort of temporal data: it's not the number of objects that grows at a crazy rate, but the number of interactions those objects have. E.g., there are a lot of stocks, but there are a lot more _prices_ of stocks, varied over time. A time series often represents a repeated measurement at some time intervals.

In this lesson, we will use a simple time series consisting of 4 measurements (randomly generated with no correlation) and measure similarity simply as being "close to each other" in their absolute values. Time series analysis of course can get much more complex, analysing affine transformations and sub-patterns, but this problem will be enough to stress our current expertise in GPU computing.

You are given another self-paced lab. These instructions and the code that you are provided will evolve over the week.

## Problem Definition

You are given an array of time samples, each consisting of 4 timestamps, and a threshold τ:

> `[<t_00, t_01, t_02, t_03>, ..., <t_{n-1}0, t_{n-1}1, t_{n-1}2, t_{n-1}3>]`.

We would like to determine if two time series are similar. In this case, we will use a very simple notion of similarity, that all their values are within a range of τ; i.e., `|t_i0 - t_j0| <= τ ∧ ... ∧ |t_i3 - t_j3 | <= τ`.

The problem is to simply count how many of the time series are similar to another one in the same dataset.

## Code Instructions

There are two files in this lesson:
  
  * [branch-div.cu](branch-div.cu): implementations of rudimentary time series similarity. A sequential CPU method is provided. You are to create a version that can run on the GPU. 
  * [../21-simt-trees/4d-points.hpp](../21-simt-trees/4d-points.hpp): reusing 4d point data as a 4-sample time series

The code is saved as a CUDA file; so, you will need to compile it with `nvcc` (likely on the Azure instance):

> nvcc -O3 -o ps branch-div.cu

(_Note however that you could compile with `g++` if there is no CUDA code by prefixing the input filename with the `-x cxx` flag._)

## Remaining Tasks

Try to work through the following tasks over the following days. The final solution will be posted around Friday afternoon.

 * Try to create a CUDA version of this CPU-parallel version, as another chance to practice a basic port of a data-level parallel program onto the GPU platform
 * Your first GPU attempt is likely to be slow (by lesson design). Consider looking through the [documentation for the NVIDIA profiler](https://docs.nvidia.com/cuda/profiler-users-guide/index.html#event-summary-mode) for ideas on how to diagnose the problem.
 * You will eventually use the ideas from [2] to resolve the limitations you discover above.


## References

[1] Rafiei & Mendelzon (1997) "Similarity-based queries for time series data." _ACM SIGMOD_. http://ezproxy.library.uvic.ca/login?url=https://dl.acm.org/doi/abs/10.1145/253260.253264

[2] Zhang et al. (2010) "Streamlining GPU applications on the fly: thread divergence elimination through runtime thread-data remapping." _ACM International Conference on Supercomputing_, 115–126. http://ezproxy.library.uvic.ca/login?url=https://dl.acm.org/doi/10.1145/1810085.1810104