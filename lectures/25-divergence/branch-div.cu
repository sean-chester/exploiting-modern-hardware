/**
 * Parallel algorithms for rudimentary time series similarity matching.
 *
 * Time series are given as a series of 4 numbers (float[4]). Two time series
 * are said to match if all their values are within a small range of each other;
 * i.e., they have the same shape. For example, <1,1,3,4> and <0,2,2,4> are
 * certainly distinct, but considered to be the same with an error tolerance >= 1,
 * because the maximum distance between any particular value is 1. 
 */

#include <chrono>     // timing library
#include <numeric>    // std::accumulate()
#include <iostream>

#include <vector>

namespace { // anonymous


auto constexpr ts_width = 4u;
using time_series = float[ ts_width ];
#include "../21-simt-trees/4d-points.hpp"



/**
 * Determines whether two TimeSeries are within a piecewise threshold of each other.
 */
template < typename TimeSeries. typename T >
    bool near_match( TimeSeries const& t1, TimeSeries const& t2, size_t const times_series_width, T const threshold )
    {
        for( auto i = 0u; i < times_series_width; ++i )
        {
            if( std::abs( t1[ i ] - t2[ i ] ) > threshold )
            {
                return false;
            }
        }
        return true;
    }

template < typename S, typename T >
    bool check_match( S * const data, uint32_t const i, T const threshold, size_t const n )
    {
        for( auto j = 0lu; j < n; ++j )
        {
            if( i != j && near_match( data[ i ], data[ j ], ts_width, threshold ) )
            {
                return true;
            }
        }
        return false;
    }

} // namespace anonymous


namespace cpu {

/**
 * Calculates the number of time series that match at least one other in the dataset,
 * given a particular threshold for piecewise error tolerance.
 */
template < typename S, typename T >
    T similar_time_series( S const& points, T const threshold, size_t const n )
    {
        auto count = 0u;

        #pragma omp parallel for reduction ( +:count )
        for( auto i = 0lu; i < n; ++i )
        {
            if( check_match( points, i, threshold, n ) )
            {
                ++count;
            }
        }

        return count;
    }

} // namespace cpu
namespace gpu {

auto const block_size = 512u;


template < typename S, typename T >
    T similar_time_series( S const& points, T const threshold, size_t const n )
    {
        auto const size = n * sizeof( points[ 0 ] );
        auto const num_blocks = ceil( n / static_cast< float >( block_size ) );

        std::vector< T > found_masks( n, 0 );

        return std::accumulate( found_masks.cbegin(), found_masks.cend(), static_cast< T >( 0 ) );
    }

} // namespace gpu


int main( int argc, char **argv )
{
    if( argc < 2 )
    {
        std::cout << "Usage: " << argv[ 0 ] << " {threshold}" << std::endl;
        std::cout << "\t{threshold} (required) = error tolerance for matching function" << std::endl;
        return 0;
    }

    auto const num_trials = 20u;
    auto const threshold = static_cast< float >( atof( argv[ 1 ] ) );
    auto const n = sizeof( points ) / sizeof( points[ 0 ] ) / 25; // increase at your own risk!
    auto sum = 0.0;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += cpu::similar_time_series( points, threshold, n );
        // sum += gpu::similar_time_series( points, threshold, n );
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
