/**
 * Parallel algorithms for rudimentary time series similarity matching.
 *
 * Time series are given as a series of 4 numbers (float[4]). Two time series
 * are said to match if all their values are within a small range of each other;
 * i.e., they have the same shape. For example, <1,1,3,4> and <0,2,2,4> are
 * certainly distinct, but considered to be the same with an error tolerance >= 1,
 * because the maximum distance between any particular value is 1. 
 */

#include <chrono>     // timing library
#include <numeric>    // std::accumulate()
#include <iostream>

#include <vector>

namespace { // anonymous

using time_series = float[ 4 ];
#include "../21-simt-trees/4d-points.hpp"

/**
 * Determines whether two time_series are within a piecewise threshold of each other.
 */
__host__ __device__
bool near_match( time_series const t1, time_series const t2, float const threshold )
{
    for( auto i = 0u; i < 4u; ++i )
    {
        if( std::abs( t1[ i ] - t2[ i ] ) > threshold )
        {
            return false;
        }
    }
    return true;
}

__host__ __device__
bool check_match( time_series * const data, uint32_t const i, float const threshold, size_t const n )
{
    for( auto j = 0lu; j < n; ++j )
    {
        if( i != j && near_match( data[ i ], data[ j ], threshold ) )
        {
            return true;
        }
    }
    return false;
}

} // namespace anonymous


namespace cpu {

/**
 * Calculates the number of time series that match at least one other in the dataset,
 * given a particular threshold for piecewise error tolerance.
 */
template < typename T >
    T similar_time_series( T const threshold, size_t const n )
    {
        auto count = 0u;

        #pragma omp parallel for reduction ( +:count )
        for( auto i = 0lu; i < n; ++i )
        {
            if( check_match( points, i, threshold, n ) )
            {
                ++count;
            }
        }

        return count;
    }

} // namespace cpu
namespace gpu {

auto const block_size = 512u;

template < typename S, typename T >
    __global__
    void has_match( uint8_t * result, S * data, T const threshold, size_t const n )
    {
        auto const i = threadIdx.x + blockIdx.x * blockDim.x;

        if( i < n )
        {
            result[ i ] = check_match( data, i, threshold, n );
        }
    }

template < typename T >
    T similar_time_series( T const threshold, size_t const n )
    {
        auto const size = n * sizeof( points[ 0 ] );
        auto const num_blocks = ceil( n / static_cast< float >( block_size ) );

        std::vector< uint8_t > found_masks( n, 0 );
        uint8_t *dev_output;
        time_series *dev_input;

        cudaMalloc( (void **) &dev_output, n * sizeof( uint8_t ) );
        cudaMalloc( (void **) &dev_input,  size );

        cudaMemcpy( dev_input, points, size, cudaMemcpyHostToDevice );

        has_match<<< num_blocks, block_size >>>( dev_output, dev_input, threshold, n );

        cudaMemcpy( found_masks.data(), dev_output, n * sizeof( uint8_t ), cudaMemcpyDeviceToHost );

        cudaFree( dev_input );
        cudaFree( dev_output );

        return std::accumulate( found_masks.cbegin(), found_masks.cend(), 0.0f );
    }

} // namespace gpu


int main( int argc, char **argv )
{
    if( argc < 2 )
    {
        std::cout << "Usage: " << argv[ 0 ] << " {threshold}" << std::endl;
        std::cout << "\t{threshold} (required) = error tolerance for matching function" << std::endl;
        return 0;
    }

    auto const num_trials = 20u;
    auto const threshold = static_cast< float >( atof( argv[ 1 ] ) );
    auto const n = sizeof( points ) / sizeof( points[ 0 ] ) / 25; // increase at your own risk!
    auto sum = 0.0;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        // sum += cpu::similar_time_series( threshold, n );
        sum += gpu::similar_time_series( threshold, n );
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
