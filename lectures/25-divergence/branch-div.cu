/**
 * Parallel algorithms for rudimentary time series similarity matching.
 *
 * Time series are given as a series of 4 numbers (float[4]). Two time series
 * are said to match if all their values are within a small range of each other;
 * i.e., they have the same shape. For example, <1,1,3,4> and <0,2,2,4> are
 * certainly distinct, but considered to be the same with an error tolerance >= 1,
 * because the maximum distance between any particular value is 1. 
 */

#include <chrono>     // timing library
#include <iostream>

namespace { // anonymous

using time_series = float[ 4 ];
#include "../21-simt-trees/4d-points.hpp"

} // namespace anonymous


namespace cpu {

/**
 * Determines whether two time_series are within a piecewise threshold of each other.
 */
bool near_match( time_series const t1, time_series const t2, float const threshold )
{
    for( auto i = 0u; i < 4u; ++i )
    {
        if( std::abs( t1[ i ] - t2[ i ] ) > threshold )
        {
            return false;
        }
    }
    return true;
}

/**
 * Calculates the number of time series that match at least one other in the dataset,
 * given a particular threshold for piecewise error tolerance.
 */
template < typename T >
    T similar_time_series( T const threshold, size_t const n )
    {
        auto count = 0u;

        #pragma omp parallel for reduction ( +:count )
        for( auto i = 0lu; i < n; ++i )
        {
            for( auto j = 0lu; j < n; ++j )
            {
                if( i != j && near_match( points[ i ], points[ j ], threshold ) )
                {
                    ++count;
                    break;
                }
            }
        }

        return count;
    }

} // namespace cpu



int main( int argc, char **argv )
{
    if( argc < 2 )
    {
        std::cout << "Usage: " << argv[ 0 ] << " {threshold}" << std::endl;
        std::cout << "\t{threshold} (required) = error tolerance for matching function" << std::endl;
        return 0;
    }

    auto const num_trials = 20u;
    auto const threshold = atof( argv[ 1 ] );
    auto const n = sizeof( points ) / sizeof( points[ 0 ] ) / 25; // increase at your own risk!
    auto sum = 0.0;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += cpu::similar_time_series( threshold, n );
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
