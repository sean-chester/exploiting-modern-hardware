/**
 * Parallel method to compute the largest gap of gaps in a list of integers.
 * E.g., {4, 8, 2, 11, 99}
 * produces gaps of < 4, -6, 9, 88>
 * which in turn has gaps of < -10, 15, 79 >
 * the largest of which is 79.
 */

#include <iostream>  // std::cout, std::endl;
#include <vector>
#include <algorithm> // std::max_element()
#include <chrono>    // timing libraries
#include <omp.h>

#include "../openmp/unsorted-small.hpp"

// Ahmdahl's Law
int sort_based()
{
	// Calculate the first transformation into gaps/diffs/skips
	std::vector< int > diffs( sizeof( input_data ) / sizeof( uint32_t ) - 2 );

	int max_element[ 2 ] = { -99999999, -99999999 };

	#pragma omp parallel for num_threads(  1)
	for( auto i = 0llu; i < diffs.size(); ++i )
	{
		auto const curr_gap = input_data[ i + 1 ] - input_data[ i ];
		auto const next_gap = input_data[ i + 2 ] - input_data[ i + 1 ];

		int const diff = next_gap - curr_gap;
		max_element[ omp_get_thread_num() ] = std::max( diff, max_element[ omp_get_thread_num() ] );
	}

	return std::max( max_element[ 0 ], max_element[ 1 ] );
}

int main()
{
	auto sum = -1;

    auto const start_time = std::chrono::system_clock::now();

	for( auto i = 0u; i < 20u; ++i )
		sum += sort_based();

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

	std::cout << sum << std::endl;
	std::cout << "time: " << ( elapsed_time.count() / (float) 20 ) << " us" << std::endl;
	return 0;
}