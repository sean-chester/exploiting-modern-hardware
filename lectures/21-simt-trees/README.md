# SIMT-Friendly Spatial Grid/Tree Partitioning

## Overview

Today is a synthesis lesson, where we put together many concepts from throughout the course so far. In particular, we are going to concurrently leverage four layers of parallelism (and enable a fifth) by combining together:

 * [Instruction-Level Parallelism (ILP)](../ilp/)
 * [Branch-free Code](../branch-pred/)
 * [Data Packing](../intra-cycle-parallelism.md)
 * [OpenMP Parallel-For Work-Sharing](../15-openmp/)
 * [Work-Efficient Algorithms](../17-work-efficiency/)
 * [SIMD Parallelism](../19-simd/)
 * [SIMT-Friendly Data Structure Design](../20-simt-graphs/)

Multi-dimensional data processing typically involves determining the spatial proximity of points such as which points are nearest each other. Thus, work-efficient algorithms nearly always impose some sort of data ordering that can group nearby in memory points that are nearby in space. [We already observed this](../17-work-efficiency/) when we ordered points by L1/Manhattan Norm so that we could break an inner loop earlier when trying to determine which points are "isolated."

Sorting multi-dimensional points for proximity is challenging because they inherently present a _partial_ rather than a _total_ order. In our earlier example, we projected the points into one dimension and sorted them by their projections. The other classic approaches are a hierarchical/tree-based grouping (e.g., an [R-tree](https://en.wikipedia.org/wiki/R-tree)) and [a static grid](https://en.wikipedia.org/wiki/Grid_(spatial_index)). The latter often leads to better parallel performance [2], partly because there are no memory loads involved in navigating a static grid. From a point's coordinates you can directly calculate its grid cell. For example, given the latitude and longitude of a location, you can immediately assert its [Marsden Square](https://en.wikipedia.org/wiki/Marsden_square) without knowing anything about any other points in the dataset: you simply divide the latitude and longitude by the appropriate grid size. Ergo, grids have a higher compute:memory ratio than trees, which is good for parallelism.

However, trees offer the advantage of pruning (or summarising) data earlier, at higher levels of the hierarchy. Today, we will build in parallel [an octree](https://en.wikipedia.org/wiki/Octree), which is a hybrid tree/grid. As a tree, it offers the typical hierarchical/recursive pruning advantages. However, the fixed `2^d` children of each node are defined statically by splitting every dimension in exactly half. This provides the advantages of a static grid in terms of computing in which child a point is found, just from its coordinates. Thereafter, it can be used by parallel (e.g., GPU) algorithms for work-efficient search space pruning.

The layout of the tree will be identical to our _flattened adjacency list_ from [the previous lecture](../20-simt-graphs/): all the points will be sorted in one large array (called "leaves") and an array of offsets (called the "directory") will indicate where each partition starts. The design _can be_ arbitrarily deep, but we will fix it to two levels today. Our task is to construct it using data packing, ILP, SIMD, _and_ multicore parallelism (following the ideas of [1]).

This task provides a second great example of how to think in a SIMT-friendly manner. In this live-coding lecture, we are given an unsorted list of points and will construct an octree from it using an algorithm that could be successfully ported to a GPU. It is our first example in this course of combining multiple layers of parallelism to achieve high parallel throughput.



## References

[1] Bøgh et al. (2017) "Template Skycube Algorithms for Heterogeneous Parallelism on Multicore and GPU Architectures." _ACM International Conference on Management of Data (SIGMOD)_, 447–462. http://ezproxy.library.uvic.ca/login?url=https://dl.acm.org/doi/10.1145/3035918.3035962

[2] Šidlauskas et al. (2009) "Trees or grids?: Indexing moving objects in main memory." _ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems (GIS)_, 236–245. http://ezproxy.library.uvic.ca/login?url=https://dl.acm.org/doi/10.1145/1653771.1653805
