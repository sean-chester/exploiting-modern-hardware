/**
 * Construct a fixed 2-level 4d octree in parallel from a set of 4d points;
 * i.e., partitions spatial data into 4^d = 256 fixed, equal-width partitions.
 */


#include "nmmintrin.h"          // for SSE4.2
#include "immintrin.h"          // for AVX
#include <chrono>               // timing library
#include <parallel/algorithm>   // __gnu_parallel::sort()
#include <iostream>

#include <vector>
#include <array>

#include "tree.hpp"

namespace { // anonymous

#include "4d-points.hpp" // statically generated vector of edge structs

} // namespace anonymous
namespace parallel {

/**
 * Fully SIMD'ised method to find the smallest 4d coordinate that bounds the entire
 * dataset.
 */
__m128 calc_max_extent( size_t const n )
{
    auto maximum = _mm_set_ps1( 0.0f ); // assuming all input values non-negative

    for( auto i = 0lu; i < n; ++i )
    {
        maximum = _mm_max_ps( maximum, _mm_load_ps( &( points[ i ][ 0 ] ) ) );
    }

    return maximum;
}


/**
 * SIMD'ised functor to calculate the packed leaf data for a given data point _i_,
 * given the three quartile points of the dataset and the number of bits
 * that should be reserved for the point id. 
 */
struct compute_leaf
{
    __m128 mid_point; /**< Point represented half of data range in each independent dimension */
    __m128 low_quart;  /**< Point represented one quarter of data range in each independent dimension */
    __m128 high_quart;  /**< Point represented 3/4'ths of data range in each independent dimension */
    uint32_t bits_for_ids; /**< Number of bits required to represent largest point id */

    leaf operator () ( uint32_t const i ) const
    {
        // First calculate masks that represent the point's relative position in each attribute
        // relative to each of the quartiles. SIMD'ised across all four dimensions.
        // Observe full ILP
        auto const input = _mm_load_ps( &( points[ i ][ 0 ] ) );
        auto mid_comp    = _mm_cmp_ps ( input, mid_point,  _CMP_GT_OS );
        auto low_comp    = _mm_cmp_ps ( input, low_quart,  _CMP_GT_OS );
        auto high_comp   = _mm_cmp_ps ( input, high_quart, _CMP_GT_OS );

        // construct the packed representation as follows
        // The _d_ most significant bits should represent the upper-level partitioning, i.e.,
        // the comparison to the midpoints of the dataset.
        // The _d_ next most significant bits should represent the second-level partitioning,
        // i.e., the comparison to the **relevant** quartile. We achieve this in a _branch-free_
        // manner by logical AND's with the midpoint mask: if the midpoint is _not set_, then
        // we take the bit from the low quartile comparison; otherwise, if it is set, we take
        // the bit from the high quartile comparison.
        // Finally, the least significant bits are reserved for the point id.
        // By OR'ing these all together, we compose the packed representation, all in 32 bits.
        return ( _mm_movemask_ps( mid_comp ) << bits_for_ids << dimensions )
             | ( _mm_movemask_ps( _mm_andnot_ps( mid_comp, low_comp  ) ) << bits_for_ids )
             | ( _mm_movemask_ps( _mm_and_ps   ( mid_comp, high_comp ) ) << bits_for_ids )
             | i;
    }
};

/** Constructs a fixed 2-level octree from an unsorted array of 4d points */  
octree to_octree()
{
    auto const n = sizeof( points ) / sizeof( point );
    
    octree tree( n );

    // Initialise functor for calculating packed leaf representations
    auto const max_point  = calc_max_extent( n );
    compute_leaf const make_leaf{ _mm_mul_ps( max_point, _mm_set_ps1( 0.5 ) )
                                , _mm_mul_ps( max_point, _mm_set_ps1( 0.25 ) )
                                , _mm_mul_ps( max_point, _mm_set_ps1( 0.75 ) )
                                , tree.bits_for_ids };

    // In parallel, calculate and store the leaf representation for each point 
    #pragma omp parallel for
    for( auto i = 0lu; i < n; ++i )
    {
        tree.leaves[ i ] = make_leaf( i );
    }

    // Sort the leaves. Exploits the packed data: most significant bits are upper-
    // level partition, so points are first sorted by that. Next most significant points
    // are lower-level partition, so points are secondarily sorted by that. Least
    // significant bits are the index in the original array, so points in the same
    // partition are sorted in their original input order.
    // The sort just treats the packed data as 32-bit ints, though, so although there
    // is an implicit 3-level sort, this has the same cost as a parallel 1-level sort of ints.
    __gnu_parallel::sort( tree.leaves, tree.leaves + n );

    // Finally, build the directory over top of the sorted leaves
    tree.build_directory();

    return tree;
}

} // namespace parallel

int main()
{
    auto sum = 0.0;
    auto const num_trials = 200u;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += parallel::to_octree().leaves[ 0 ]; // arbitrary choice; take first leaf
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
