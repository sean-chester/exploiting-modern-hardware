/**
 * Construct a 2-level octree in parallel from a set of 4d points
 */


#include "nmmintrin.h"          // for SSE4.2
#include "immintrin.h"          // for AVX
#include <chrono>               // timing library
#include <parallel/algorithm>   // __gnu_parallel::sort()
#include <iostream>

#include <vector>
#include <array>

#include "tree.hpp"

namespace { // anonymous

#include "4d-points.hpp" // statically generated vector of edge structs

} // namespace anonymous
namespace parallel {

auto calc_max_extent( size_t const n )
{
    auto maximum = _mm_set_ps1( 0u ); // assuming all input values non-negative

    for( auto i = 0lu; i < n; ++i )
    {
        maximum = _mm_max_ps( maximum, _mm_load_ps( &( points[ i ][ 0 ] ) ) );
    }

    return maximum;
}


template < typename T >
    struct compute_leaf
    {
        T mid_point;
        T low_quart;
        T high_quart;
        uint32_t bits_for_ids;

        leaf operator () ( uint32_t const i ) const
        {
            auto const input = _mm_load_ps( &( points[ i ][ 0 ] ) );
            auto mid_comp    = _mm_cmp_ps ( input, mid_point,  _CMP_GT_OS );
            auto low_comp    = _mm_cmp_ps ( input, low_quart,  _CMP_GT_OS );
            auto high_comp   = _mm_cmp_ps ( input, high_quart, _CMP_GT_OS );

            return ( _mm_movemask_ps( mid_comp ) << bits_for_ids << dimensions )
                 | ( _mm_movemask_ps( _mm_andnot_ps( mid_comp, low_comp  ) ) << bits_for_ids )
                 | ( _mm_movemask_ps( _mm_and_ps   ( mid_comp, high_comp ) ) << bits_for_ids )
                 | i;
        }
    };


octree to_octree()
{
    auto const n = sizeof( points ) / sizeof( point );
    
    octree tree( n );

    auto const max_point  = calc_max_extent( n );
    compute_leaf< __m128 > const make_leaf{ _mm_mul_ps( max_point, _mm_set_ps1( 0.5 ) )
                                , _mm_mul_ps( max_point, _mm_set_ps1( 0.25 ) )
                                , _mm_mul_ps( max_point, _mm_set_ps1( 0.75 ) )
                                , tree.bits_for_ids };

    #pragma omp parallel for
    for( auto i = 0lu; i < n; ++i )
    {
        tree.leaves[ i ] = make_leaf( i );
    }

    __gnu_parallel::sort( tree.leaves, tree.leaves + n );

    tree.build_directory();

    return tree;
}

} // namespace parallel

int main()
{
    auto sum = 0.0;
    auto const num_trials = 200u;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += parallel::to_octree().leaves[ 0 ]; // arbitrary choice; take first leaf
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
