/**
 * Definition of octree data structure and related data types
 */

#ifndef CSC586C_TREE
#define CSC586C_TREE

#include <cstddef>   // size_t
#include <stdint.h>  // uint32_t
#include <cassert>   // assert()
#include <algorithm> // std::lower_bound()

auto const dimensions = 4u;
using coord = float;
using leaf = uint32_t;
using node = leaf;
using point = __attribute__ ((aligned(16))) float[ dimensions ];


class octree
{
public:

    octree( size_t n ) : leaves( new leaf[ n ] )
	                   , bits_for_ids( std::ceil( std::log2( n ) ) )
	                   , num_leaves( n )
	{
	    assert( "Dataset does not overflow data type"
	       && ( bits_for_ids < 8 * sizeof( leaf ) - 2 * dimensions ) );
	}


    ~octree() { delete[] leaves; }

    void build_directory()
    {
	    auto const cell_mask = ~( ( 1u << bits_for_ids ) - 1 );

	    #pragma omp parallel for
	    for( auto i = 0u; i < ( 1u << dimensions ); ++i )
	    {
	        directory[ i ] = std::lower_bound( leaves
	                                         , leaves + num_leaves
	                                         , i << bits_for_ids
	                                         , [ = ]( auto const val, auto const key )
	                                           {
	                                                return ( val & cell_mask ) < key;
	                                           } )
	                       - leaves;
	    }
	}

    node __attribute__((aligned(16)))  directory[ 1 << dimensions ];
    leaf  __attribute__((aligned(16))) *leaves;
    uint32_t bits_for_ids;
    size_t num_leaves;
};


#endif // CSC586C_TREE
