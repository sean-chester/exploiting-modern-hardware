/**
 * Definition of octree data structure and related data types. Also describes
 * method for producing the upper-level directory structure, once the leaves have
 * been computed and sorted.
 *
 * Exploits a 32-bit packed representation for the leaves. The bits represent, in order:
 * [upper-level partition id][lower-level partition id][index in original input array].
 * Note that this implies the tree is a *secondary* index.
 */

#ifndef CSC586C_TREE
#define CSC586C_TREE

#include <cstddef>   // size_t
#include <stdint.h>  // uint32_t
#include <cassert>   // assert()
#include <algorithm> // std::lower_bound()

// Static dimensionality for data
auto const dimensions = 4u;

// Aliases for semantic types
using coord = float;
using leaf = uint32_t;
using node = leaf;
using point = __attribute__ ((aligned(16))) float[ dimensions ];


/**
 * A recursive data structure that splits every dimension exactly in half at each level
 * of the tree. This implementation has a fixed depth of 2, which partitions the data
 * space into 4^d = 256 equal-size grid cells.
 *
 * Implemented as two flat 1d arrays. The bottom level has width n (number of points)
 * where each leaf is a packed unsigned integer that encodes that point's upper level
 * partition, lower-level partition, and index in the original (unchanged) input array.
 * The top level is a directory structure that indicates where the points for each
 * data structure begin, very similar to the compressed sparse row format we used
 * in lecture ../20-simt-graphs 
 *
 * @see https://en.wikipedia.org/wiki/Octree
 */
class octree
{
public:

	/** Constructs and allocates space for a new octree with n leaves */
    octree( size_t n ) : leaves( new leaf[ n ] )
	                   , bits_for_ids( std::ceil( std::log2( n ) ) )
	                   , num_leaves( n )
	{
	    assert( "2d + lg(n) fits in packed data type"
	       && ( bits_for_ids < 8 * sizeof( leaf ) - 2 * dimensions ) );
	}


	/** Deletes and de-allocates the octree */
    ~octree() { delete[] leaves; }

    /** Constructs the upper-level directory structure based on the data in leaves */
    void build_directory()
    {
    	// the leaves have a packed data structure, so we need to clear off the point ids
    	// to leave only the partition information. This mask clears all the lg(n) least
    	// significant bits; a logical and with this mask will return only the partition info.
	    auto const cell_mask = ~( ( 1u << bits_for_ids ) - 1 );

	    // for each of the 2^d upper-level partitions, run a binary search in parallel
	    // over (pre-sorted) leaves to determine where the partition begins and write
	    // that into the directory
	    #pragma omp parallel for
	    for( auto i = 0u; i < ( 1u << dimensions ); ++i )
	    {
	        directory[ i ] = std::lower_bound( leaves
	                                         , leaves + num_leaves
	                                         , i << bits_for_ids // shift to partition range
	                                         , [ = ]( auto const val, auto const key )
	                                           {
	                                                return ( val & cell_mask ) < key;
	                                           } )
	                       - leaves; // get index, not iterator as returned by std::lower_bound()
	    }
	}

    node __attribute__((aligned(16)))  directory[ 1 << dimensions ]; /**< Indicates where each partition starts */
    leaf  __attribute__((aligned(16))) *leaves; /**< Packed leaf data, sorted by partition */
    uint32_t bits_for_ids; /**< Number of bits in packed leaf structure reserved for point ids */
    size_t num_leaves; /**< Number of leaves in the octree */ 
};


#endif // CSC586C_TREE
