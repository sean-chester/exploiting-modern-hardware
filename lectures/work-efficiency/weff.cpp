/**
 * Parallel method to calculate outlier points, i.e., those that lie at least a
 * distance of _r_ from any other point in the dataset.
 * E.g., given points {<2,1>, <1,2>, <2,2>, <5,5>, <1,6>} and a range of 1
 * returns {<5,5>, <1,6>}.
 */

#include <iostream>  // std::cout, std::endl;
#include <chrono>    // timing libraries
#include <omp.h>

#include <vector>

#include "point.hpp"


namespace { // anonymous

using coord = uint32_t;
std::vector< point< coord > > input_data{ {2,1}, {1,2}, {2,2}, {5,5}, {1,6} };


uint32_t find_anomalies( uint32_t const range )
{
	std::vector< point< coord > > result;
	std::vector< bool > in_range( input_data.size(), false );

	// coarse- vs fine-grained parallelism + schedule dynamic
	// manhattan or euclidean distance sort?

	#pragma omp parallel for
	for( auto i = 0u; i < input_data.size() - 1; ++i )
	{
		for ( auto j = i + 1; j < input_data.size(); ++j )
		{
			if( within_range( input_data[ i ], input_data[ j ], range ) )
			{
				in_range[ i ] = true;
				in_range[ j ] = true;
			}
		}
	}

	std::copy_if( in_range.cbegin(), in_range.cend(), std::back_inserter( result ),
		[]( auto const v ){ return v == false; } );

	return 0;
}


} // namespace anonymous




int main()
{
	auto sum = 0llu;

    auto const start_time = std::chrono::system_clock::now();

	for( auto i = 0u; i < 20u; ++i )
		sum += find_anomalies( 1u );

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

	std::cout << sum << std::endl;
	std::cout << "time: " << ( elapsed_time.count() / (float) 20 ) << " us" << std::endl;
	return 0;
}