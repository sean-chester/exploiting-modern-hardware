/**
 * Alternative methods to calculate a prefix sum in sequential on a CPU or
 * in parallel on a GPU.
 *
 * The prefix sum calculates for every index i the sum of all values at
 * all indexes that precede it.
 * For example, the input vector <3,1,4,0,2>
 * would be transformed into the output vector <0,3,4,8,8>
 */

#include <chrono>     // timing library
#include <algorithm>  // std::sort(), std::lower_bound()
#include <iostream>
#include <omp.h>      // OpenMP parallelisation libraries

#include <vector>

namespace { // anonymous

#include "../19-simd/xvals.hpp" // pre-generated c-style array of floats

} // namespace anonymous


namespace seq {
namespace efficient {

/**
 * Calculates the prefix sum sequentially in O(n) time.
 */
template < typename T >
    void prefix_sum( T* output, T const* input, size_t const n )
    {
        if( n > 0 )
        {
            T sum = output[ 0 ] = 0;
            std::transform( input
                          , input + n - 1
                          , output + 1
                          , [ &sum ]( T const val ){ return sum += val; } );
        }
    }


} // namespace efficient
} // namespace seq

namespace par {
namespace naive {
/**
 * Calculates the prefix sum sequentially in brute-force O(n^2) time.
 * Designed to match the naive GPU algorithm for comparison.
 */
template < typename T >
    void prefix_sum( T* output, T const* input, size_t const n )
    {
        #pragma omp parallel for
        for( auto i = 0lu; i < n; ++i )
        {
            output[ i ] = 0;
            for( auto j = 0lu; j < i; ++j )
            {
                output[ i ] += input[ j ];
            }
        }

        return;
    }

} // namespace naive
} // namspace par
namespace gpu {

auto const block_size = 512u;

namespace naive {

/**
 * Naive GPU kernel in which the assigned thread t_i calculates the i'th prefix sum
 * naively by summing all the values in the input array that precede it.
 */
template < typename T >
    __global__
    void naive_prefix( T* sum, T const* input, size_t const n )
    {
        auto const i = threadIdx.x + blockIdx.x * blockDim.x;

        if( i < n )
        {
            sum[ i ] = 0;
            for( auto j = 0lu; j < i; ++j )
            {
                sum[ i ] += input[ j ];
            }
        }
    }

/**
 * Calculates the prefix sum on the GPU. This method sets up the device memory allocations
 * and data transfers and invokes the naive GPU kernel.
 */
template < typename T >
    void prefix_sum( T* output, T const* input, size_t const n )
    {
        auto const size = n * sizeof( T );
        auto const num_blocks = ceil( n / static_cast< float >( block_size ) );

        T *dev_output, *dev_input;
        cudaMalloc( (void **) &dev_output, size );
        cudaMalloc( (void **) &dev_input,  size );

        cudaMemcpy( dev_input, input, size, cudaMemcpyHostToDevice );

        naive_prefix<<< num_blocks, block_size >>>( dev_output, dev_input, n );

        cudaMemcpy( output, dev_output, size, cudaMemcpyDeviceToHost );

        cudaFree( dev_input );
        cudaFree( dev_output );

        return;
    }

} // namespace naive
} // namespace gpu



int main( int argc, char **argv )
{
    if( argc < 2 )
    {
        std::cout << "Usage: " << argv[ 0 ] << " {num runs}" << std::endl;
        std::cout << "\t{num runs} (required) = Number of times to run the program and average results" << std::endl;
        return 0;
    }

    auto const num_trials = static_cast< uint32_t >( atoi( argv[ 1 ] ) );
    auto const n = sizeof( xvals ) / sizeof( xvals[ 0 ] );
    auto sum = 0.0;
    float output[ n ];

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        // seq::efficient::prefix_sum( output, xvals, n );
        // par::naive::prefix_sum( output, xvals, n );
        gpu::naive::prefix_sum( output, xvals, n );

        sum += output[ n - 1 ];
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
