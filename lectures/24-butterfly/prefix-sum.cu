/**
 * Alternative methods to calculate a prefix sum in sequential on a CPU or
 * in parallel on a GPU.
 *
 * The prefix sum calculates for every index i the sum of all values at
 * all indexes that precede it.
 * For example, the input vector <3,1,4,0,2>
 * would be transformed into the output vector <0,3,4,8,8>
 */

#include <chrono>             // timing library
#include <algorithm>          // std::sort(), std::lower_bound()
#include <iostream>

#include <vector>

namespace { // anonymous

#include "../15-openmp/unsorted-data.hpp" // pre-generated c-style array of uints

} // namespace anonymous


namespace seq {

/**
 * Calculates the prefix sum of sequentially.

 */
template < typename T >
    void prefix_sum( std::vector< T > & output, std::vector< T > const& input )
    {
        if( ! input.empty() )
        {
            T sum = output[ 0 ] = 0;
            std::transform( input.begin()
                          , input.end() - 1
                          , output.begin() + 1
                          , [ &sum ]( T const val ){ return sum += val; } );
        }
    }


} // namespace seq
namespace gpu {

/**
 * Calculates the prefix sum on the GPU.
 */
template < typename T >
    void prefix_sum( std::vector< T > & output, std::vector< T > const& input )
    {
        return;
    }

} // namespace gpu



int main()
{
    auto sum = 0.0;
    auto const num_trials = 2000u;

    std::vector< uint32_t > const input( std::begin( input_data ), std::end( input_data ) );
    std::vector< uint32_t> output( input.size(), 0 );

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        seq::prefix_sum( output, input );
        // gpu::prefix_sum( output, input );

        sum += output.back();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
