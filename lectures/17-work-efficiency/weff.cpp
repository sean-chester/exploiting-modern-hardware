/**
 * Parallel method to calculate outlier points, i.e., those that lie at least a
 * distance of _r_ from any other point in the dataset.
 * E.g., given points {<2,1>, <1,2>, <2,2>, <5,5>, <1,6>} and a range of 1
 * returns {<5,5>, <1,6>}.
 */

#include <iostream>  // std::cout, std::endl;
#include <algorithm> // std::copy_if()
#include <chrono>    // timing libraries
#include <omp.h>     // OpenMP header for parallelisation
#include <cassert>   // assert()

#include <vector>

#include "point.hpp" // point< T > struct and associated functions


namespace { // anonymous

using coord = uint32_t;
using point_set = std::vector< point< coord > >;
using flag_set = std::vector< uint16_t >;

// statically-defined pre-built random, uniformly-distributed dataset with independent dimensions
#include "point-data.hpp"


/**
 * Returns the subset of points that are not in the exclude_list. Sequential method.
 */
point_set copy_if_false( flag_set const& exclude_list, point_set const& points )
{
    assert( "list lengths match" && exclude_list.size() == points.size() );

    point_set result;
    result.reserve( points.size() );
    auto const n = exclude_list.size();

    for( auto i = 0lu; i < n; ++i )
    {
        if( ! exclude_list[ i ] )
        {
            result.push_back( points[ i ] );
        }
    }

    return result;
}


/**
 * Determines in parallel which input_points are *not isolated*, given a threshold range for proximity.
 * @return A flag_set indicating for each point whether or not it is non-isolated
 *
 * Quadratic complexity!
 */
flag_set find_non_isolated_points( point_set input_points
                                 , coord const range )
{
    // The overall algorithmic strategy is to compare every point to every other point
    // exactly once. We maintain a set of boolean flags that indicate if a point is
    // within a range of another point; whenever two points p and q are determined
    // to be within range of each other, we set the flag for both of them.
    // At the end, the flags are set for those and only those points in range of some
    // other point.
    // This algorithm parallelises relatively well (subject to some questions of workload
    // balance), and has sequential access patterns, but it incurs a lot of work, i.e.,
    // the number of instructions is high.
    // If there is an algorithm that can compute the response in substantially (or even
    // asymptotically) fewer instructions, then we would call this algorithm *work-inefficient*.
    //
    // TODO: Can we develop a more work-efficient algorithm? I.e., one that does not do
    // n(n-1)/2 comparisons?

    flag_set in_range( input_points.size(), 0 );
    auto const n = input_points.size();

    // Here we use very coarse-grained parallelism. I.e., each thread gets n/t values of
    // i and then runs the entire inner loop. Because the iteration strategy is triangular
    // (i.e., j starts at i + 1), this will likely lead to poor workload balance.
    // Parallelising the inner loop instead would produce much finer-grained parallelism
    // with all parallel tasks of equal size, but there would be more overhead to assigning
    // tasks n times.
    // For a compromise, we can use the `schedule` keyword. A *static* parallelisation assigns
    // all work evenly at compile-time. This *dynamic* schedule creates work batches of 64
    // iterations. When a thread completes its current batch of 64, it grabs the next incomplete
    // batch; i.e., the work distribution self-balances. However, the cost is the dynamic
    // allocation of work; thus the compromise which often requires tuning.
    #pragma omp parallel for schedule( dynamic, 64 )
    for( auto i = 0lu; i < n; ++i )
    {
        // Note: on average, we compare every point to half the dataset!
        // TODO: How can we improve this? (Consider the sort)
        for ( auto j = i + 1; j < n && input_points[ j ].mag <= input_points[ i ].mag + 2 * range; ++j )
        {
            if( within_range( input_points[ i ], input_points[ j ], range ) )
            {
                // Observe that `in_range[ j ] = 1` looks like a race condition, as multiple
                // threads may try to concurrently write to the same address.
                // This is an example of a "safe" race, because they are writing a literal,
                // not a value that depends on the current value at the address (i.e., there
                // is no read, only write) *and* all threads would be writing the exact same
                // value.
                // I.e., no matter what order the threads access this, the result will be
                // the same.
                // This is a great example of how data-level parallelism can be exposed when
                // it *appears* that there is a contention.
                in_range[ i ] = 1u;
                in_range[ j ] = 1u;
            }
        }
    }

    return in_range;
}


/**
 * Returns the subset of input_points that are not within range of any other input_points
 */
point_set find_anomalies( point_set input_points
                        , coord const range )
{
	// sort data by distance to origin so that spatially near points
    // are physically near in array.
    // TODO: Question to class: How to take advantage of this?? ðŸ¤”
    for( auto & p : input_points )
    {
        p.mag = p.x + p.y;
    }

	std::sort( std::begin( input_points )
             , std::end  ( input_points )
             , sort_by_l2_to_O{} );

    return copy_if_false( find_non_isolated_points( input_points, range )
                        , input_points );
}


} // namespace anonymous



int main()
{
	auto sum = 0llu;
    auto const num_trials = 2000u;
    auto const threshold = 100u;

    auto const start_time = std::chrono::system_clock::now();

	for( auto i = 0u; i < num_trials; ++i )
    {
        // Just add up result sizes so that something is done with the output
		sum += find_anomalies( input_data, threshold ).size();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

	std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
	std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
	return 0;
}
