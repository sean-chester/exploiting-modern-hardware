/**
 * Parallel method to calculate outlier points, i.e., those that lie at least a
 * distance of _r_ from any other point in the dataset.
 * E.g., given points {<2,1>, <1,2>, <2,2>, <5,5>, <1,6>} and a range of 1
 * returns {<5,5>, <1,6>}.
 */

#include <iostream>  // std::cout, std::endl;
#include <algorithm> // std::copy_if()
#include <chrono>    // timing libraries
#include <omp.h>     // OpenMP header for parallelisation

#include <vector>

#include "point.hpp"


namespace { // anonymous

using coord = uint32_t;
using point_set = std::vector< point< coord > >;
using flag_set = std::vector< bool >;

#include "point-data.hpp"


point_set copy_if_false( flag_set const& exclude_list, point_set const& points )
{
    point_set result;
    result.reserve( input_data.size() );

    for( auto i = 0lu, n = exclude_list.size(); i < n; ++i )
    {
        if( ! exclude_list[ i ] )
        {
            result.push_back( points[ i ] );
        }
    }

    return result;
}


flag_set find_non_isolated_points( point_set input_points
                                 , coord const range )
{
    flag_set in_range( input_points.size(), false );
    auto const n = input_points.size();

    // coarse- vs fine-grained parallelism + schedule dynamic
    #pragma omp parallel for
    for( auto i = 0lu; i < n; ++i )
    {
        for ( auto j = i + 1; j < n; ++j )
        {
            if( within_range( input_points[ i ], input_points[ j ], range ) )
            {
                in_range[ i ] = true;
                in_range[ j ] = true;
            }
        }
    }

    return in_range;
}


point_set find_anomalies( point_set input_points
                        , coord const range )
{
	// sort data by distance to origin so that spatially near points
    // are physically near in array
	std::sort( std::begin( input_points )
             , std::end  ( input_points )
             , sort_by_l2_to_O{} );

    return copy_if_false( find_non_isolated_points( input_points, range )
                        , input_points );
}


} // namespace anonymous




int main()
{
	auto sum = 0llu;
    auto const num_trials = 2000u;
    auto const threshold = 100u;

    auto const start_time = std::chrono::system_clock::now();

	for( auto i = 0u; i < num_trials; ++i )
    {
		sum += find_anomalies( input_data, threshold ).size();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

	std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
	std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
	return 0;
}
