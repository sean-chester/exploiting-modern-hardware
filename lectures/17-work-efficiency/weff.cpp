/**
 * Parallel method to determine which points are isolated, i.e., those that lie at least a
 * distance of _r_ from any other point in the dataset.
 *
 * E.g., given points {<2,1>, <1,2>, <2,2>, <5,5>, <1,6>} and a range of 1
 * returns {0,0,0,1,1}, because <2,1> and <1,2> are both within a Euclidean (L2)
 * distance of 1 from <2,2>, but <5,5> and <1,6> do not have any nearby neighbours.
 */

#include <iostream>           // std::cout, std::endl;
#include <chrono>             // timing libraries
#include <omp.h>              // OpenMP header for parallelisation
#include <cassert>            // assert()

#include <vector>

#include "point.hpp" // point< T > struct and associated functions


namespace { // anonymous

using coord = uint32_t;
using point_set = std::vector< point< coord > >;
using flag_set = std::vector< bool >;

// statically-defined pre-built random, uniformly-distributed dataset with independent dimensions
// L1-resident (circa 8KB)
#include "point-data.hpp"


/**
 * Determines in parallel which input_points are "socially distanced", given a threshold range
 * for proximity.
 * @return A flag_set indicating for each point whether or not it is non-isolated
 *
 * Quadratic complexity!
 */
flag_set confirm_range( point_set input_points
                      , coord const range )
{
    return flag_set( input_points.size(), true ); // optimism!
}

} // namespace anonymous



int main()
{
	auto sum = 0llu;
    auto const num_trials = 20000u;
    auto const threshold = 100u;

    auto const start_time = std::chrono::system_clock::now();

	for( auto i = 0u; i < num_trials; ++i )
    {
        // Just add up last elements so that something is done with the output
		sum += confirm_range( input_data, threshold ).back();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

	std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
	std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
	return 0;
}
