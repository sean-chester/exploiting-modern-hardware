/**
 * Transforms a graph from an unsorted list of edges to an adjacency list format in parallel
 */

#include <chrono>             // timing library
#include <algorithm>          // std::sort(), std::lower_bound()
#include <parallel/algorithm> // __gnu_parallel::sort()
#include <iostream>

#include <vector>

#include "graph.hpp" // data structures and types for this lesson

namespace { // anonymous

#include "edges.hpp" // statically generated vector of edge structs
auto const m = edges.size();

} // namespace anonymous


namespace sequential {

vertex get_max_vertex()
{
    vertex max_vertex = 0;
    for( auto const e : edges )
    {
        max_vertex = std::max( max_vertex, e.u );
        max_vertex = std::max( max_vertex, e.v );
    }
    return max_vertex;
}

degree_sequence get_degree_sequence( vertex const n )
{
    degree_sequence deg_seq( n, 0u );
    for( auto const e : edges )
    {
        ++deg_seq[ e.u ];
    }
    return deg_seq;
}

degree_sequence prefix_sum( degree_sequence deg_seq )
{
    vertex prev = 0;
    for( auto i = 0lu, n = deg_seq.size(); i < n; ++i )
    {
        std::swap( prev, deg_seq[ i ] );
        prev += deg_seq[ i ];
    }

    return deg_seq;
}


adj_list to_adjacency_list()
{
    auto const n = 1u + get_max_vertex();
    adj_list neighbours( n );

    for( auto const e : edges )
    {
        neighbours[ e.u ].push_back( e.v );
    }

    return neighbours;
}


flat_adj_list to_flat_adjacency_list()
{
    auto const n = 1u + get_max_vertex();

    auto const deg_seq = prefix_sum( get_degree_sequence( n ) );
    degree_sequence curr_offsets( n, 0u );
    std::vector< vertex > neighbours( edges.size() );

    for( auto const e : edges )
    {
        neighbours[ deg_seq[ e.u ] + curr_offsets[ e.u ]++ ] = e.v;
    }

    return { deg_seq, neighbours };
}


flat_adj_list sort_first()
{
    auto const n = 1u + get_max_vertex();

    std::vector< vertex > neighbours( edges.size() );
    degree_sequence offsets( n + 1, 0u );

    std::sort( std::begin( edges )
             , std::end( edges )
             , []( auto l, auto r ){ return l.u < r.u; } );

    auto num_edges = 0u;
    for( auto const e : edges )
    {
        neighbours[ num_edges++ ] = e.v;
        offsets[ e.u + 1 ] = num_edges;
    }

    for( auto i = 1u; i < n; ++i )
    {
        if( offsets[ i ] == 0 )
        {
            offsets[ i ] = offsets[ i - 1 ];
        }
    }

    offsets.resize( n );
    return { offsets, neighbours };
}

} // namespace sequential
namespace parallel {


void set_max_vertex( vertex & max_vertex )
{
    #pragma omp for reduction( max:max_vertex )
    for( auto i = 0lu; i < m; ++i )
    {
        max_vertex = std::max( max_vertex, edges[ i ].u );
        max_vertex = std::max( max_vertex, edges[ i ].v );
    }
}

void populate_degree_sequence( degree_sequence & deg_seq, vertex const n )
{
    #pragma omp single
    deg_seq = degree_sequence( n, 0 );

    #pragma omp for
    for ( auto i = 0lu; i < m; ++i)
    {
        __sync_fetch_and_add( &( deg_seq[ edges[ i ].u ] ), 1 );

    } // implicit barrier
}

void calculate_offsets( degree_sequence & offsets, vertex const n )
{
    #pragma omp single
    offsets = sequential::prefix_sum( degree_sequence( offsets ) );
}

void populate_neighbour_list( std::vector< vertex > & neighbours, auto const& offsets, auto & curr_offsets, vertex const n )
{
    #pragma omp single
    curr_offsets = degree_sequence( n, 0 );

    #pragma omp for
    for( auto i = 0lu; i < m; ++i )
    {
        auto const u = edges[ i ].u;
        auto const v = edges[ i ].v;

        auto const u_idx = __sync_fetch_and_add( &( curr_offsets[ u ] ), 1 );

        neighbours[ offsets[ u ] + u_idx ] = v;

    } // implicit barrier
}

flat_adj_list to_flat_adjacency_list()
{
    vertex max_v = 0;
    degree_sequence offsets, curr_offsets;
    std::vector< vertex > neighbours( m );

    #pragma omp parallel
    {
        set_max_vertex( max_v );
        populate_degree_sequence( offsets, max_v + 1 );
        calculate_offsets( offsets, max_v + 1 );
        populate_neighbour_list( neighbours, offsets, curr_offsets, max_v + 1 );

    } // parallel section

    return { offsets, neighbours };
}

flat_adj_list sort_first()
{
    vertex n = 0u;
    degree_sequence offsets;
    std::vector< vertex > neighbours( edges.size() );

    __gnu_parallel::sort( std::begin( edges )
                        , std::end( edges )
                        , []( auto l, auto r ){ return l.u < r.u; } );

    #pragma omp parallel
    {
        set_max_vertex( n );

        #pragma omp single
        offsets = degree_sequence( n + 1 );

        #pragma omp for nowait
        for( auto i = 0u; i < m; ++i )
        {
            neighbours[ i ] = edges[ i ].v;
        }

        #pragma omp for
        for( auto i = 0u; i <= n; ++i )
        {
            offsets[ i ] = std::distance( std::cbegin( edges )
                                        , std::lower_bound( std::cbegin( edges )
                                                          , std::cend  ( edges )
                                                          , i
                                                          , []( auto edge, auto u ){ return edge.u < u; } ) );
        }
    }

    return { offsets, neighbours };
}

} // namespace parallel



int main()
{
    auto sum = 0.0;
    auto const num_trials = 2000u;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        // sum += sequential::to_adjacency_list().node_offsets.back();
        // sum += sequential::to_flat_adjacency_list().node_offsets.back();
        // sum += sequential::sort_first().node_offsets.back();
        // sum += parallel::to_flat_adjacency_list().node_offsets.back();
        sum += parallel::sort_first().node_offsets.back();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
