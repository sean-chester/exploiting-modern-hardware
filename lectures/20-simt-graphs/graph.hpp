/**
 * Definition of graph-related data structures and data types
 */


#ifndef CSC586C_GRAPH
#define CSC586C_GRAPH

using vertex = uint32_t;
using degree = vertex;

/** Indicate an edge `e=(u,v)` of a graph */
struct edge
{
    vertex u;
    vertex v;
};

/** Equality operator for the edge struct */
bool inline operator == ( edge l, edge r )
{
	return l.u == r.u && l.v == r.v;
}

/** Inequality operator for the edge struct */
bool inline operator != ( edge l, edge r )
{
	return ! operator == ( l, r );
}

/**
 * An adjacency list (https://en.wikipedia.org/wiki/Adjacency_list) is a list of lists,
 * one for each vertex _v_, that gives all the neighbours of _v_
 */
using adj_list = std::vector< std::vector< vertex > >;

/**
 * A degree sequence is a mapping from vertex id i to the degree of that vertex,
 * i.e., the number of edges incident to it.
 */
using degree_sequence = std::vector< degree >;


/**
 * A "flattened adjacency list" is an adjacency list that has been "flattened" from a 2d
 * vector of vectors to two 1d vectors. This format is often more amenable to use on parallel
 * platforms, such as GPUs.
 *
 * The vector `neighbours` (of length _m_, i.e., the number of edges) gives the destination _v_ of
 * every edge `e=(u,v)`. They are sorted by source vertex, _u_.
 *
 * The vector `node_offsets` (of length _n_, i.e., the number of vertices) indexes into `neighbours`.
 * The value at index i indicates where in `neighbours` begin the edges with vertex _i_ as a source.
 *
 * For example, the graph given by unsorted edges: `<(0,1),(0,3),(2,4),(4,3),(0,2),(1,3)>`
 * would have `neighbours = <1,3,2,3,4,3>`
 * and would have `node_offsets = <0,3,4,5,5>`.
 * This indicates that neighbours in range [0,3), i.e., <1,3,2>, belong to vertex 0, neighbours in
 * range [3,4), i.e., <3>, belong to vertex 1, neighbours in range [4,5), i.e., <4>, belong to
 * vertex 2, neighbours in range [5,5), i.e., <>, belong to vertex 3, and neighbours in range [5,m),
 * i.e., <3>, belong to vertex 4.
 */
struct flat_adj_list
{
    degree_sequence node_offsets;
    std::vector< vertex > neighbours;
};

#endif
