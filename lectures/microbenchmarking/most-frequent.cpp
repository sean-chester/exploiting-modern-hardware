/**
 * An investigation into data access patterns and their importance to performance.
 * Given a contiguous input array, find the element that occurs most often in the input.
 * We derived two main approaches, a hash-based O(n) algorithm and a sort-based O(n lg n)
 * algorithm, which are both implemented below. The sort-based algorithm has better
 * access patterns and cache performance and surprisingly outperforms. We will spend
 * the next month understanding this result better.
 */

#include <iostream>  // std::cout
#include <cassert>	 // assert()

#include "timing.hpp"
#include "data-generation.hpp"


namespace hash{

struct find_frequentest
{
	/**
	 * The hash-based approach does one simple scan over the dataset
	 * and uses a mapping from element->count in a hash map to track
	 * how often everything was seen. At the end, we do one simple,
	 * second scan over the hash map's values to extract the key that
	 * had appeared most often in the input data.
	 */
	template < typename T >
		T operator () ( std::vector< T > data ) const
		{
			assert( "Not empty" && data.size() > 0 );

			std::unordered_map< T, uint32_t > counts;

			// Put everything in the hash map
			for( T const& el : data )
			{
				++counts[ el ];
			}

			// Use C++ STL to scan the hash map and pull out the key corresponding
			// to the largest value/count. 
			return std::max_element( counts.cbegin()
				 				   , counts.cend()
                                   , []( auto const best, auto const next )
                                     {
                                        return next.second > best.second;
                                     })->first;
		}
};
}


namespace sorting{

struct find_frequentest
{
	/**
	 * The sort-based approach incurs an O(n lg n) cost to first sort the data,
	 * but then benefits by only needing a single scan over the data and no complex
	 * data structures to keep track of counts; in fact, we only need four integers
	 * during our scan to track the best solution.
	 */
	template < typename T >
		T operator () ( std::vector< T > data ) const
		{
			assert( "Not empty" && data.size() > 0 );

			// We keep track of the best seen solution as a pair
			// ( element, count ). We can initialise it with a count
			// of zero (and any arbitrary element) and be certain that
			// this initialisation will be overwritten by any element
			// that we see.
			auto result = std::make_pair( data.front(), 0u );

			// Our O(n lg n) preprocessing step that enables a very fast scan
			std::sort( data.begin(), data.end() );

			// For the scan, we repeatedly check each element against its successor.
			// If it is the same, then we increment the number of times that we have seen it;
			// otherwise, we know this is the last occurrence and we can compare it to `result`
			// Note the loop terminates early because we look ahead one position.
			auto num_times = 1u;
			for( auto i = 0u; i < data.size() - 1; ++i )
			{
				if( data[ i ] == data[ i + 1 ] )
				{
					++num_times;
				}
				else /* We found a new element; check if this was the best result so far */
				{
					if( num_times > result.second )
					{
						result = { data[ i ], num_times };
					}

					// Reset our counter for the next element at data[ i + 1 ]
					num_times = 1u;
				}
			}

			// It is possible that the largest element in the vector was also the
			// most frequent, in which case we never would have executed the branches
			// inside the loop. Thus we check this edge condition here.
			if( num_times > result.second )
			{
				result = { data.back(), num_times };
			}

			return result.first;
		}
};
}



int main()
{
	auto num_tests  = 1u;
	auto input_size = 1u << 20;

    // For random numbers, one must first seed the random number generator. This is the idiomatic
    // approach for the random number generator libraries that we have chosen.
    std::srand ( static_cast< uint32_t >( std::time(0) ) );

	auto const test_cases = csc586::benchmark::uniform_rand_vec_of_vec< uint32_t >( num_tests
                                                                                   , input_size );
	
	// toggle namespace (`sorting` or `hash`) to change which implementation is run
	auto const run_time   = csc586::benchmark::benchmark( sorting::find_frequentest{}
                                                         , test_cases );

    std::cout << "Average time (us): " << run_time << std::endl;

	return 0;
}
