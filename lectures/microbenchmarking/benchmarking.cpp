#include <iostream>
#include <random> 		// std::rand, std::srand, std::default_random_engine
#include <cmath>		// sqrt()

#include "timing.hpp"
#include "unique_elements.hpp"


int mwe_benchmark()
{
	auto const avg_time = csc586::microbenchmark::benchmark(
		  []( uint32_t const val ){ return sqrt( val ); }
		, [](){ return static_cast< uint32_t >( std::rand() ); }
		, 10000000u
	);

	std::cout << "Average time per mwe function call = " << avg_time << " us" << std::endl;
	return 0;
}

struct get_benchmark_vector
{
	std::vector< uint32_t > operator() ( size_t const n ) const
	{
		std::vector< uint32_t > vec;
		vec.reserve( n + 1u );

		// push unique random val onto vector
		// or'ing with 1 ensures the value (used as a multiplier below) cannot be zero
		vec.push_back( std::rand() | 1 );

		for( uint32_t i = 0u; i < n / 2; ++i )
		{
			// create random val and push it twice onto vector
			// multiplying by vec.front() ensures unique val isn't duplicated
			auto const x = std::rand() * vec.front();
			vec.push_back( x );
			vec.push_back( x );
		}

		// randomise order
		std::shuffle( vec.begin(), vec.end(), std::default_random_engine{} );

		return vec;
	}
};


int main()
{
	std::srand ( unsigned ( std::time(0) ) );
	mwe_benchmark();

	// Observe: different random vector for each function!
	
	auto const avg_map = csc586::microbenchmark::benchmark(
		  csc586::unique::map_based{}
		, get_benchmark_vector{}
		, 1u
	);

	auto const avg_sort = csc586::microbenchmark::benchmark(
		  csc586::unique::bit_based{}
		, get_benchmark_vector{}
		, 100000u
	);

	auto const avg_bit = csc586::microbenchmark::benchmark(
		  csc586::unique::bit_based{}
		, get_benchmark_vector{}
		, 100000u
	);

	std::cout << "Average time per map-based call  = " << avg_map << " us" << std::endl;
	std::cout << "Average time per bit-based call  = " << avg_bit << " us" << std::endl;
	std::cout << "Average time per sort-based call = " << avg_sort << " us" << std::endl;
	return 0;
}