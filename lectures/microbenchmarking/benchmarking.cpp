#include <iostream>
#include <random> 		// std::rand, std::srand, std::default_random_engine
#include <cmath>		// sqrt()

#include "timing.hpp"
#include "../intro-dm/unique_element.hpp"

/**
 * Creates and returns a vector pre-populated with size calls to RandomGenerator gen
 */
template < class RandomGenerator >
	auto build_rand_vec( RandomGenerator gen, size_t const size )
	{
		std::vector< decltype((gen)()) > random_data( size );
		std::generate( random_data.begin(), random_data.end(), gen );

		return random_data;
	}

int mwe_benchmark()
{
	auto const n = 10000000u;

	auto const avg_time = csc586::microbenchmark::benchmark(
		  []( uint32_t const val ){ return sqrt( val ); }
		, []()
		  {
			return build_rand_vec( []()
			{
				return static_cast< uint32_t >( std::rand() );
			}
			, n );
		  }()
	);

	std::cout << "Average time per mwe function call = " << avg_time << " us" << std::endl;
	return 0;
}

struct get_benchmark_vector
{
	size_t static const n = 3200u;

	std::vector< uint32_t > operator() () const
	{
		std::vector< uint32_t > vec;
		vec.reserve( n + 1u );

		// push unique random val onto vector
		// or'ing with 1 ensures the value (used as a multiplier below) cannot be zero
		vec.push_back( std::rand() | 1 );

		for( uint32_t i = 0u; i < n / 2; ++i )
		{
			// create random val and push it twice onto vector
			auto const x = std::rand();
			vec.push_back( x );
			vec.push_back( x );
		}

		// randomise order
		std::shuffle( vec.begin(), vec.end(), std::default_random_engine{} );

		return vec;
	}
};


int main()
{
	std::srand ( unsigned ( std::time(0) ) );
	mwe_benchmark();

	auto const random_data = build_rand_vec(
							   get_benchmark_vector{}
							,  100u
							);
	
	auto const avg_map = csc586::microbenchmark::benchmark(
		  []( auto const& v ){ return csc586::unique::map_based( v ); }
		, random_data
	);

	auto const avg_sort = csc586::microbenchmark::benchmark(
		  []( auto const& v ){ return csc586::unique::sort_based( v ); }
		, random_data
	);

	auto const avg_bit = csc586::microbenchmark::benchmark(
		  []( auto const& v ){ return csc586::unique::bit_based( v ); }
		, random_data
	);

	auto const avg_2loo = csc586::microbenchmark::benchmark(
		  []( auto const& v ){ return csc586::unique::two_loops( v ); }
		, random_data
	);

	auto const avg_skip = csc586::microbenchmark::benchmark(
		  []( auto const& v ){ return csc586::unique::skip_based( v ); }
		, random_data
	);

	std::cout << "Average time per map-based call  = " << avg_map  << " us" << std::endl;
	std::cout << "Average time per bit-based call  = " << avg_bit  << " us" << std::endl;
	std::cout << "Average time per two-loops call  = " << avg_2loo << " us" << std::endl;
	std::cout << "Average time per skip-based call = " << avg_skip << " us" << std::endl;
	std::cout << "Average time per sort-based call = " << avg_sort << " us" << std::endl;
	return 0;
}