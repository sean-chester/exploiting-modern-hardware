/**
 * Various methods for determining the only unique element in a vector
 */

#ifndef CS586_UNIQUE
#define CS586_UNIQUE

#include <cassert>		 // assert()
#include <unordered_map>

namespace csc586 {
namespace unique {

struct map_based
{	
	template < typename T >
		T operator() ( std::vector< T > const& vec )
		{
			assert( "Vector contains data" && ! vec.empty() );
			using count = uint32_t;

			std::unordered_map< T, count > element_counts;

			for( auto const& val : vec )
			{
				if( element_counts.count( val ) > 0 )
				{
					++element_counts[ val ];
				}
				else
				{
					element_counts[ val ] = 1u;
				}
			}

			for( auto const [ val, count ] : element_counts )
			{
				if( 1u == count )
				{
					return val;
				}
			}

			// Unreachable code block on well-defined input
			assert( "Vector contained no unique element!" );
			return *vec.cbegin();
		}
};

/**
 * Calculates result by xor'ing all the values together. Any duplicate ones will cancel each other out.
 * @pre Assumes that duplicate values appear an even number of times
 */
struct bit_based
{
	uint32_t operator () ( std::vector< uint32_t > const& vec ) const
	{
		assert( "Vector contains data" && ! vec.empty() );
		uint32_t result = 0u;

		for( auto const i : vec )
		{
			result ^= i;
		}

		return result;
	}
};

/**
 * Calculates result by sorting all the values and then scanning for the unique one.
 */
struct sort_based
{
	uint32_t operator() ( std::vector< uint32_t > vec ) const
	{
		assert( "Vector contains data" && ! vec.empty() );
		assert( "Vector does not contain exactly 2 elements" && vec.size() != 2 );

		std::sort( std::begin( vec ), std::end( vec ) );

		// check edge case that unique element is the smallest
		if( 1u == vec.size() ) { return *vec.cbegin(); }
		if( *std::cbegin( vec ) != *std::next( std::cbegin( vec ), 1u ) ) { return *vec.cbegin(); }

		// otherwise scan every sorted triplet and check if the middle val is unique
		for( auto it = vec.begin() + 1; it != vec.end(); ++it )
		{
			if( *it != *( it - 1 ) && *it != *( it + 1 ) )
			{
				return *it;
			}
		}

		// Unreachable code block on well-defined input
		assert( "Vector contained no unique element!" );
		return 0u;
	}
};

} // namespace unique
} // namespace csc586

#endif // CS586_UNIQUE