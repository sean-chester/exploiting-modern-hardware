/**
 * Timing library to microbenchmark and comparatively analyse different implementation approaches
 */

#ifndef CS586_TIMING
#define CS586_TIMING

#include <vector>
#include <algorithm> // std::generate()
#include <chrono>	 // timing libraries

namespace csc586 {
namespace microbenchmark {

using duration = float;

/**
 * Creates and returns a vector pre-populated with size calls to RandomGenerator gen
 */
template < class RandomGenerator >
	auto build_rand_vec( RandomGenerator gen, size_t const size )
	{
		std::vector< decltype((gen)()) > random_data( size );
		std::generate( random_data.begin(), random_data.end(), gen );

		return std::move( random_data );
	}

/**
 * Microbenchmarks the average time to run Function f, using num_rounds instances
 * of input randomly generated by RandomGenerator rand
 */
template < class Function, class RandomGenerator >
	duration benchmark( Function f, RandomGenerator rand, uint32_t const num_rounds )
	{
		auto const random_data = build_rand_vec( rand, num_rounds );

		// start timer
		auto const start_time = std::chrono::steady_clock::now();

		// run function f num_rounds times
		for( auto const& random_input : random_data )
		{
			f( random_input );
		}

		// end timer
		auto const end_time = std::chrono::steady_clock::now();

		// return average time
		return std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time ).count() 
			/ static_cast< duration >( num_rounds );
	}


} // namespace microbenchmark
} // namespace csc586

#endif // CS586_TIMING