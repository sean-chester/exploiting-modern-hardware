/**
 * Timing library to microbenchmark and comparatively analyse different implementation approaches
 */

#ifndef CS586_TIMING
#define CS586_TIMING

#include <algorithm> // std::for_each()
#include <chrono>	 // timing libraries

namespace csc586 {
namespace microbenchmark {

using duration = float;

/**
 * Microbenchmarks the average time to run Function f, using num_rounds instances
 * of input randomly generated by RandomGenerator rand
 */
template < class Function, class Container >
	duration benchmark( Function f, Container random_data )
	{
		// start timer
		auto const start_time = std::chrono::steady_clock::now();

		// run function f on every random instance, do something with output
		auto output = 0.0;
		std::for_each( std::cbegin( random_data )
					 , std::cend  ( random_data )
					 , [&output, f]( auto const& v ){ output += f(v); } );
		std::cout << output << std::endl;

		// end timer
		auto const end_time = std::chrono::steady_clock::now();

		// return average time
		return std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time ).count()
			/ static_cast< duration >( random_data.size() );
	}


} // namespace microbenchmark
} // namespace csc586

#endif // CS586_TIMING