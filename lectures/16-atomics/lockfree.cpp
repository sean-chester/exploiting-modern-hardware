/**
 * A demonstration of multi-threaded synchronisation via hardware atomics.
 * We are building an append-only "lock-free" queue (i.e., one half of a
 * producer/consumer queue).
 *
 * Demo problem is to return a sub-vector of all numbers >= 500, using parallelism
 * E.g., {428, 827, 2, 111, 949}
 * returns {827, 949} OR {949, 827}, i.e., this is parallel code and the output order does not matter.
 */

#include <iostream>  // std::cout, std::endl;
#include <chrono>    // timing libraries
#include <omp.h>     // OpenMP parallelisation library

#include <vector>

namespace { // anonymous

#include "../15-openmp/unsorted-data.hpp" // statically-generated input data

} // namespace anonymous
namespace serial {

template < typename T >
    std::vector< T > over_threshold( T const threshold )
    {
        auto const n = sizeof( input_data ) / sizeof( input_data[ 0 ] );

        std::vector< T > result;

        for( auto i = 0lu; i < n; ++i )
        {
            if( input_data[ i ] >= threshold )
            {
                result.push_back( input_data[ i ] );
            }
        }

        return result;
    }

} // namespace serial


int main( int argc, char **argv )
{
    if( argc < 3 )
    {
        std::cout << "Usage: " << argv[ 0 ] << " [threshold] [num_threads]" << std::endl;
        return 0;
    }

    auto sum = 0lu;
    auto const num_trials = 200lu;
    auto const threshold = static_cast< uint32_t >( atoi( argv[ 1 ] ) );
    omp_set_num_threads( atoi( argv[ 2 ] ) );

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        // Toggle between the lesson options by changing the namespace below:
        sum += serial::over_threshold( threshold ).size();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}




// auto const tail = __sync_fetch_and_add( &result_size, 1 );