/**
 * Parallel method to return a sub-vector of all numbers >= 500
 * E.g., {428, 827, 2, 111, 949}
 * returns {827, 949}.
 */

#include <iostream>  // std::cout, std::endl;
#include <chrono>    // timing libraries
#include <omp.h>

#include "../openmp/unsorted-small.hpp"


uint32_t branchfree_over_threshold( uint32_t const threshold )
{
	auto const n = sizeof( input_data ) / sizeof( uint32_t );
	std::vector< uint32_t > result( n );

	auto result_size = 0u;

	for( auto i = 0u; i < n; ++i )
	{
		result[ result_size ] = input_data[ i ];
		result_size += ( input_data[ i ] >= threshold );
	}

	result.resize( result_size );
	return result;
}


uint32_t lockfree_over_threshold( uint32_t const threshold )
{
	auto const n = sizeof( input_data ) / sizeof( uint32_t );
	std::vector< uint32_t > result( n );

	auto result_size = 0u;

	#pragma omp parallel for
	for( auto i = 0u; i < n; ++i )
	{
		result[ result_size ] = input_data[ i ];

		if( input_data[ i ] >= threshold )
		{
			auto const index = __sync_fetch_and_add( &result_size, 1 );
			result_size [ index ] = input_data[ i ];
		}
	}

	result.resize( result_size );
	return result;
}

int main()
{
	auto sum = 0llu;

    auto const start_time = std::chrono::system_clock::now();

	for( auto i = 0u; i < 20u; ++i )
		sum += foo();

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

	std::cout << sum << std::endl;
	std::cout << "time: " << ( elapsed_time.count() / (float) 20 ) << " us" << std::endl;
	return 0;
}