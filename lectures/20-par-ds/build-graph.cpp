/**
 * Transforms a graph from an unsorted list of edges to an adjacency list format in parallel
 */


#include "nmmintrin.h" // for SSE4.2
#include "immintrin.h" // for AVX
#include <chrono>      // timing library
#include <iostream>

#include <vector>

namespace { // anonymous

using vertex = uint32_t;

struct edge
{
    vertex u;
    vertex v;
};

#include "edges.hpp" // statically generated vector of edge structs

// struct graph
// {
//     std::vector<> edge_list;
// };

vector< vector< vertex > >; 

size_t to_adjacency_list()
{
    vertex max_v = 0;

    #pragma omp parallel for reduction( max:max_v )
    for( auto i = 0lu; i < edges.size(); ++i )
    {
        max_v = std::max( max_v, edges[ i ].u );
        max_v = std::max( max_v, edges[ i ].v );
    }

    std::vector< uint32_t > degrees( max_v + 1, 0 );
    std::vector< uint32_t > cur_index( max_v + 1, 0 );

    #pragma omp parallel for
    for ( auto i = 0lu; i < edges.size(); ++i)
    {
        __sync_fetch_and_add( &( degrees[ edges[ i ].u ] ), 1 );
        __sync_fetch_and_add( &( degrees[ edges[ i ].v ] ), 1 );
    }

    std::vector< vertex > neighbours( 2 * edges.size() );

    #pragma omp parallel for
    for( auto i = 0lu; i < edges.size(); ++i )
    {
        auto const j = __sync_fetch_and_add( &( cur_index[ edges[ i ].u ] ), 1 );
        neighbours[ degrees[ edges[ i ].u ] + j ] = edges[ i ].v;

        auto const j2 = __sync_fetch_and_add( &( cur_index[ edges[ i ].v ] ), 1 );
        neighbours[ degrees[ edges[ i ].v ] + j2 ] = edges[ i ].u;
    }

    return edges.size();
}

} // namespace anonymous

int main()
{
    auto sum = 0.0;
    auto const num_trials = 20000u;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += to_adjacency_list();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}


    // #pragma omp parallel
    // for( auto i = 0lu; i < edges.size(); ++i )
    // {
    //     auto const th_id = omp_get_thread_num();

    //     if( ( edges[ i ].u % omp_get_num_theads() ) == th_id  )
    //     {

    //     }
    // }