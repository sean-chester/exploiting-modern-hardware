/**
 * Construct a 2-level octtree from a set of 4d points
 */


#include "nmmintrin.h" // for SSE4.2
#include "immintrin.h" // for AVX
#include <chrono>      // timing library
#include <iostream>

#include <vector>

namespace { // anonymous

using coord = float;

struct __attribute__ ((aligned(16))) point
{
    float dims[ 4 ];
};

#include "4d-points.hpp" // statically generated vector of edge structs

size_t to_octree()
{
    auto const n = sizeof( points ) / sizeof( point );
    auto const dimensions = 4;
    point maximum{ 0, 0, 0, 0 };

    for( auto i = 0lu; i < n; ++i )
    {
        for( auto j = 0lu; j < dimensions; ++j )
        {
            maximum[ j ] = std::max( maximum[ j ], points[ i ][ j ] );   
        }
    }

    std::vector< std::pair< uint32_t, uint32_t > > sorted_points( n );

    #pragma omp parallel for
    for( auto i = 0lu; i < n; ++i )
    {
        uint32_t node_id = 0;
        for( auto j = 0lu; j < dimensions; ++j )
        {
            node_id |= ( ( points[ i ][ j ] < maximum[ j ] / 2 ) << ( dimensions + j ) );

            if( points[ i ][ j ] < maximum[ j ] / 2 )
            {
                node_id |= ( ( points[ i ][ j ] < maximum[ j ] / 4 ) << ( j ) );
            }
            else
            {
                node_id |= ( ( points[ i ][ j ] < maximum[ j ] * 3 / 4 ) << ( j ) );
            }
        }
    }

    std::sort( sorted_points.begin(), sorted_points.end() );

    // separate array for each dimension, i.e., SoA

    return n;
}

} // namespace anonymous

int main()
{
    auto sum = 0.0;
    auto const num_trials = 20000u;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += to_octree();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
