/**
 * Toy example porting the 19-simd algorithm to CUDA for an NVIDIA GPU
 *
 * Calculates the average size of set of 3d vectors.
 * Example input: {{1,1,1},{2,2,2}}
 * I.e., 1 vector of size (3*1^2)^-0.5 and 1 vector of size (3*2^2)^0.5
 * Example output: ( sqrt(3) + sqrt(12) ) / 2 = 2.59808
 */

#include "math.h" 	   // sqrtf()
#include <chrono>      // timing library
#include <cassert>     // assert()
#include <numeric>     // std::accumulate()
#include <iostream>


int const blocksize = 512; 

#include "xvals.hpp"
#include "yvals.hpp"
#include "zvals.hpp"


__global__
void vector_length( float *x, float *y, float *z, float *result, size_t n )
{
    int const index = threadIdx.x + blockIdx.x * blockDim.x;

    if( index < n )
    {
        result[ index ] = sqrt( x[ index ] * x[ index ]
                              + y[ index ] * y[ index ]
                              + z[ index ] * z[ index ] );
    }
}


float average_vector_length()
{
    assert( "all coords present" && sizeof( xvals ) == sizeof( yvals ) && sizeof( yvals ) == sizeof( zvals ) );
    auto const size = sizeof( xvals );
    auto const n = size / sizeof( xvals [ 0 ] );

    float *dev_x, *dev_y, *dev_z, *dev_result;
    float result[ n ];

    cudaMalloc( (void **) &dev_x, size );
    cudaMalloc( (void **) &dev_y, size );
    cudaMalloc( (void **) &dev_z, size );
    cudaMalloc( (void **) &dev_result, size );

    cudaMemcpy( dev_x, xvals, size, cudaMemcpyHostToDevice );
    cudaMemcpy( dev_y, yvals, size, cudaMemcpyHostToDevice );
    cudaMemcpy( dev_z, zvals, size, cudaMemcpyHostToDevice );

    vector_length<<< n / blocksize, blocksize >>>( dev_x, dev_y, dev_z, dev_result, n );

    cudaMemcpy( result, dev_result, size, cudaMemcpyDeviceToHost );

    cudaFree( dev_x );
    cudaFree( dev_y );
    cudaFree( dev_z );
    cudaFree( dev_result );

    return std::accumulate( result, result + n, 0.0f ) / n;
}


int main()
{
    auto sum = 0.0;
    auto const num_trials = 20000u;

    auto const start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < num_trials; ++i )
    {
        sum += average_vector_length();
    }

    auto const end_time = std::chrono::system_clock::now();
    auto const elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>( end_time - start_time );

    std::cout << "answer: " << ( sum  / static_cast< float >( num_trials ) ) << std::endl;
    std::cout << "time: " << ( elapsed_time.count() / static_cast< float >( num_trials ) ) << " us" << std::endl;
    return 0;
}
