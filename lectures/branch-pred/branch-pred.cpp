/**
 * Simple program to test the effect of unpredictable branching on performance. Inspired
 * by https://stackoverflow.com/a/11227902/2769271
 *
 * Note that we are including a statically defined input array so that we can measure
 * performance counters effectively with the Linux tool `perf`, as there is minimal
 * overhead in setting up this experiment. You should run `data-generator.cpp` prior
 * to running this experiment, or you will get errors: the compiler will not be able
 * to find the included files unsorted-data.hpp and sorted-data.hpp (which is where
 * the statically defined input is declared).
 *
 * To see the effect of branch prediction, toggle code in sum_over_threshold();
 * specifically, you should observe much slower performance with unsorted data
 * and the conditional functor than when enabling either the sorted data or the 
 * branchless functor. You may need to lower your compiler optimisation level to -Og.
 *
 * You should be able to directly observe the effect using perf (may require sudo) in
 * default mode, which includes counters for the total number of branches, the number
 * mispredicted, and the misprediction rate:
 *
 * > perf stat ./binary-name
 */

#include <iostream> // std::cout, std::endl
#include <chrono>   // std::chrono
#include <numeric>  // std::accumulate()


// Note that we have given the unsorted data and the sorted data the same name in our
// header files. Here we include each into a different namespace. As a result,
// we avoid a name collision and can toggle between choices with a simple using statement;
// c.f., sum_over_threshold().
namespace unsorted {
#include "unsorted-data.hpp"
}

namespace sorted {
#include "sorted-data.hpp"
}


/**
 * Functors that adds a value to a running sum iff the value is >= the functor's threshold.
 */
template < typename T >
    struct conditional_sum
    {
        T const threshold;

        T operator ()( T const init, T const value ) const
        {
            // Observe that the return value of this function is dependent on value.
            // The processor will try to *predict* which branch (if or else) to
            // speculatively execute.
            // In our unsorted example, threshold is set to be the mid-point of a uniformly-
            // distributed dataset; so, this test is as predictable as an unbiased coin flip.
            // However, when the data is sorted, there is a clear pattern that can be used
            // for prediction; i.e., roughly the first half of the data will fall through to
            // the else and the remainder of the array will execute the body of the if.
            if( value >= threshold )
            {
                return init + value;
            }
            else
            {
                return init;
            }
        }
    };


/**
 * Branchless functor to add a value to a running sum iff the value is >= functor threshold
 */
template < typename T >
    struct branchless_sum
    {
        T const threshold;

        T operator ()( T const init, T const value ) const
        {
            // Here we exploit a common trick to *eliminate* the branch.
            // This is called "branch-free" or "branchless" code.
            // Observe that we still have a *condition*, we just don't jump
            // to a different spot on the code as a result of the condition.
            // The trick here is to exploit that a condition in c/c++ evaluates
            // to either 0 (false) or 1 (true). We can use those values just
            // like any other integer. When we multiply value by 0/false, nothing
            // is added to init; wen we multiply value by 1/true, value is added.
            // A compiler really ought to do this on your behalf, and it should
            // be rare that this will provide a speed up at a high level of
            // optimisation (e.g., -O3).
            return init + value * ( value >= threshold );
        }
    };


/**
 * Calculates the sum of all values in input_data[] that are above the given threshold.
 * Compared to yesterday's ILP lecture, this invokes branching, which creates an
 * entirely different bottleneck in the program (or path in the Intel top-down analysis method).
 */
template < typename T >
    T sum_over_threshold( T const threshold )
    {
        // Toggle the experiment by flipping the commented lines and recompiling.
        // There are four combos, depending on whether the data is sorted and whether you use
        // the branchless or conditional functor.


        // These namespaces toggle whether to use the input_data defined in unsorted-data.hpp
        // or sorted-data.hpp. This is equivalent to having written below: unsorted::input_data
        // If you enable both, you will get a compile error for having an ambiguous reference
        // to input_data.
        using namespace unsorted;
        // using namespace sorted;

        // We used c-style static arrays, so there is no .size() function. We have to compute the
        // length of the array using the sizeof() function, which returns the number of bytes that
        // a variable occupies.
        size_t const n = sizeof( input_data ) / sizeof ( uint32_t );


        return std::accumulate( input_data, input_data + n, 0, conditional_sum< T >{ threshold } );
        // return std::accumulate( input_data, input_data + n, 0,  branchless_sum< T >{ threshold } );
    }


int main()
{
    auto sum = 0llu;
    auto const benchmark_trials = 2000u;
    auto const threshold = 500llu;

    auto start_time = std::chrono::system_clock::now();

    for( auto i = 0u; i < benchmark_trials; ++i )
    {
        sum += sum_over_threshold( threshold );
    }

    auto end_time = std::chrono::system_clock::now();
    auto elapsed_time = std::chrono::duration_cast< std::chrono::microseconds >( end_time - start_time );

    std::cout << "sum = " << sum << std::endl;
    std::cout << "average time per run: "
              << elapsed_time.count() / static_cast< float >( benchmark_trials )
              << " us" << std::endl;

    return 0;
}
