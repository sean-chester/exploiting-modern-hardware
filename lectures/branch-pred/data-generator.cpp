/**
 * Generates two random headers files that contain statically defined arrays of uniformly distributed
 * uint32_t values in the range [0, 1000). The first header file contains randomly-ordered data
 * and the second header file contains the same data sorted in ascending order.
 */

#include <iostream>  // std::cout, std::endl
#include <cstring>   // std::strcmp()
#include <fstream>   // std::ofstream
#include <stdlib.h>  // srand(), rand()
#include <algorithm> // std::sort(), std::for_each()
#include <vector>


/**
 * Creates a new header file with the given filename, in which the input vector data
 * is declared as a static array, e.g., the vector <1,2,3> produces a file with one
 * line as follows:
 * ```
 * uint32_t input_data[] = { 1, 2, 3 };
 * ```
 */
void write_to_file( const char * filename, std::vector< uint32_t > data )
{
    std::ofstream file;
    file.open( filename );

    file << "uint32_t input_data[] = { ";
    std::for_each( data.begin(), data.end() - 1, [ &file ]( auto const val ){ file << val << ", "; } );
    file << data.back() << " };" << std::endl;

    file.close();
}


/**
 * Generates an array of n uniformly-distributed random uint32_t values and writes them
 * to `unsorted-data.hpp`. Also writes a sorted version of the same data to `sorted-data.hpp`.
 */
void write_random_data( size_t const n )
{
    // seed random number generator
    srand (time(NULL));

    // Populate a new vector of length n with random uint32_t's in the range [0, 1000).
    std::vector< uint32_t > data( n );
    std::generate( std::begin( data ), std::end( data ), [](){ return rand() % 1000; } );

    // Write unsorted and sorted copies to file.
    write_to_file( "unsorted-data.hpp", data );
    std::sort( std::begin( data ), std::end( data ) );
    write_to_file( "sorted-data.hpp", data );
}

// This time we are handling input from the command line.
// In c/c++ these are stored into the parameters argc and argv of main().
// argc gives the number of command line arguments, and argv is an array
// of c-style strings that contain each string. argv[0] is always the name
// of the executable/binary.
//
// In this program, we are accepting an array length as input from the command line.
// An example execution to generate header files with arrays of length 10^6 would be:
// ./binary-name 1000000
int main( int argc, char** argv )
{
    // Lightweight input checking. If no arguments are given, or typical help flags are provided,
    // print out usage instructions and quit.
    if( argc < 2 || std::strcmp( argv[ 1 ], "-h" ) == 0 || std::strcmp( argv[ 1 ], "--help" ) == 0 )
    {
        std::cout << "Usage:" << std::endl;
        std::cout << argv[ 0 ] << " [n]" << std::endl;
        std::cout << "\tn: length of randomly generated arrays" << std::endl;
        return 0;
    }

    // atoi() converts from "ascii to int", i.e., from the c-style string
    // given as input on the command line to an integral type (size_t in this case).
    size_t const array_length = atoi( argv[ 1 ] );
    write_random_data( array_length );

    return 0;
}
