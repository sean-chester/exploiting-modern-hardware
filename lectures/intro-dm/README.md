# 03 - Data Management Intro Lecture (Live Coding)

In this lecture we dive straight into working through a toy data management problem --- learn by doing!
 * simple enough that we can come up with viable solutions together in class
 * however, maybe not as straight-forward as on the surface it appears
 * we will take a blended prototypical approach: testing, implementing, and designing concurrently, with all three components informing each other
   - we use experiments to learn more about our problem and inspire new algorithmic ideas
   - we use algorithmic insights to define new experiments
   - this is part of the vertical thinking (across layers of abstraction) that we want to develop in this course


## The Lone Unique Value (LUV) problem

 * problem def: Let `unique(B)` denote the set of unique values (i.e., the vocabulary) of a bag of numbers, `B = {x_i}`. Task is to retrieve the only `x_j \in B` s.t. `|unique(B)| > |unique( B \ x_j)|`.
   - many data management problems can be formulated as mathematical functions like this, though not usually unary functions
   - we want to find an algorithm (+ implementation) that can solve the function on very large inputs "very fast"
     + in research, "very fast" requiring < 1/10th the time as the previously best known solution
       - can come from asymptotic improvement, but there are other ways.

 * problem defined by example:
   - `LUV(<3, 6, 4, 6, 1, 2, 4, 3, 6, 2>) = 1`
   - `LUV(<>) = undefined` (`<>` is not in the input domain for this function)
   - `LUV(<2, 2, 2, 2, 2, 2, 2, 2, 1>) = 1`
   - `LUV(<1, 2, 3, 2, 1>) = 3`
   - `LUV(<1, 1>) = undefined` (`<1,1>` is not in the input domain for this function)
   - how could you more elegantly handle these undefined cases (by modifying the problem definition?)


 * not hard to transform this into a "real" data management problem.
   - we are detecting an anomaly or a constraint violation: the number that does not fit the underlying pattern of the dataset
   - imagine if the scale is 10^20 numbers and we need real-time interaction
   - or new numbers come in at a rate of 10^6/minute, we are monitoring dataset for new anomalies
   - or instead of numbers we have more complex objects (e.g., subgraphs of a social network)
   - often, the "hot spot" of a "real" problem comes down to a simple _kernel_ like this
   - however, "good" problems also have to have important, topical applications (at least if you want to publish them)


## Test-Driven Algorithmics?

 * no one way to go about solving a problem like LUV
 * in class, started by translating our problem definition (by example) into a test suite
   - each input/output example above translates perfectly into a test case
     + we run our algorithm/implementation on each input instance and check that it produces the correct output value
   - especially when it comes to parallelism, having tests in place already will be invaluable for verifying program behaviour
   - early tests can guide us more efficiently towards more promising algorithmic ideas 
   - used unit test framework, [Catch2](https://github.com/catchorg/Catch2).
     + The github repo contains a great tutorial and `tests.cpp` documents how we have used it.
 * you may prefer an IDE; in class I compiled on command line using the gnu c++ compiler (g++)
 > g++ -Wall -Og -std=c++17 tests.cpp -o tests

 * Flags specified to compiler:
   - Observe that `tests.cpp` is the input file to `g++`; the rest are flags to the compiler
   - `-Wall` means "with all warnings" (i.e., including those not enabled by default) and is good defensive programming practice
   - `-Og` means "with compiler optimisation level set for debugging"; for performance you would use `-O3` instead (optimisation level 3)
   - `-std=c++17` means "use features from the 2017 c++ standard"; they are not enabled by default. We used _structured bindings_ from c++17 in our code
   - `-o [filename]` means "link and create an executable named `filename`", in our cases called `tests` (I did not give a filename extension)
   - If using an IDE (recommended!) you will need to determine how to enable these flags in that specific IDE
     * some suggestions: MS Visual Studio, CLion, CodeBlocks, Eclipse


## LUV solutions

  * In this lecture, we came up with three high-level ideas and a prediction of their performance based on asymptotic analysis
    - One based on hashing that we expect to be linear cost (with some assumptions about hash function performance)
    - One based on a bit twiddling hack, namely that x^x=0, that is linear (one scan of B)
    - One two-phase algorithm that initially sorts the data and then scans the sorted list. O(B lg |B|) because of the sort
      + We also came up with three alternative micro-optimisations for the scanning procedure in this approach
  * We implemented all algorithms (in 45 minutes), but we did not write a `main()` method! Really, we never built an application. However, we have a test suite to verify correctness of the algorithms
    + could prove correctness theoretically, but we are testing correctness of the implementation too
    + test suite should evolve with new edges cases over time (e.g., every time we find a bug, add that case to our test suite)
    + catch2 generated the main method/application for us
    + we run the tests with the executable generated by compiling our tests with catch2: `./tests`


## Limitations/Next Lecture(s)

  * Many people stop at this point; after all, we have asymptotic analysis to tell us which algorithm to choose. However,
    + Asymptotic analysis gives us the performance _in the limit_. The results on a _practical input domain_ may be surprising
    + We have two linear-cost algorithms (though the xor algorithm is restricted to some further assumptions)
    + None of these implementations have been _optimised_ yet. In fact, we know very little about how they will perform
  * We will code up another set of tests to compare the algorithms in terms of _performance_ (rather than correctness)
    + We will also start to express code with a functional programming paradigm in C/C++


## Questions?
  
  * Don't hesitate to ask. I'll update this README (or code docs) with any clarifications inspired by student questions.
