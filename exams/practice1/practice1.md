# Practice Midterm 1


Q1) Please explain the following concepts in 1-3 sentences:

 a. instruction-level parallelism

 b. temporal locality

 c. spatial locality

 d. L2 cache stall

 e. the "memory wall"


Q2) Somebody else in your "pod" asks you to review the following code and claims that it is "memory-bound." How would you verify or refute their claim? [The more precise that you are, the more marks you will receive (assuming the precision is also correct!).]

```
float data[] = {...};

int main()
{
	double sum = 0;
	size_t const n = sizeof( data ) / sizeof( float );

	for( auto i = 0u; i < n - 100; ++i )
	{
		if( data[ i ] > data[ i + 100 ] )
		{
			sum += data[ i ];
		}
	}

	return 0;
}
```

Q3) The following code finds the duplicate value in a list. How would you improve its cache performance (and thus efficiency)? [The more precise that you are, the more marks you will receive (assuming the precision is also correct!).] Justify your response.

```
#include <iostream>

float data[] = {...};

int main()
{
	size_t const n = sizeof( data ) / sizeof( float );

	for( int i = 0; i < n; ++i )
	{
		for( int j = 0; j < n; ++j )
		{
			if( data[ i ] == data[ j ] )
			{
				std::cout << data[ i ];
				return 0;
			}
		}
	}

	std::cout << "No duplicates found! ðŸ˜¬" << std::endl;

	return 0;
}
```


Q4) Assume that a student is recorded by their id (6 digits), age, gpa (9-point scale), subject (from an enum of 16 possibilities), and gender (a float between 0 (M) and 1 (F)). From a list of students, you are to print out all details of the youngest one that is studying CS and has a GPA > 7.0.

Please provide your data structure(s) (i.e., struct/class definitions) that would most efficiently support this query, including both the students and the list of students. Justify your response, including any explanations for specific data types (e.g., `int32_t` vs `uint_64t`). You can specify (pseudo-)code if you feel this helps your explanation, but it is not required. Your justification should describe *why* this is more efficient than other alternatives. [syntactic correctness is not important, as long as the concepts are clear.]

E.g., given the following input:

<V00111111, 22, 7.1, CS, 0.001>
<V00111111, 43, 5.1, MATH, 0.100>
<V00111111, 19, 4.1, CIV, 0.200>
<V00111111, 18, 6.5, CS, 0.300>
<V00111111, 72, 8.7, CS, 0.400>

The output would be:

<V00111111, 22, 7.1, CS, 0.001>.


Q5) Assume that everybody has a nemesis, i.e., that a person is defined as:

```
struct person
{
	person *nemesis;
	std::string name;
};
```

Given a list of persons, you are determine if their links creates a directed, acyclic graph (DAG)^; i.e., never creates a loop. In what order would the list of persons optimise cache behaviour for this query? Justify your response.

E.g., given the following input:

<Alice, Bob>
<Bob, Carol>
<Carol, Alice>

The result would be TRUE, because of the path (Alice, Bob)->(Bob, Carol)->(Carol, Alice).

But given the input:

<Alice, Bob>
<Bob, Carol>
<Carol, Dave>

The result would be FALSE, because no matter with whom you start, you cannot find a path back to that person.
