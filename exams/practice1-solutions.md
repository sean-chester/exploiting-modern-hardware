# Practice Midterm 1 - Solutions

Q1) Please explain the following concepts in 1-3 sentences (2 marks each):

The responses do not need to be elaborate or dictionary-like. 1 mark is awarded if the response indicates a general sense of the concept. 2 marks are awarded if the response is fairly precise.

 a. instruction-level parallelism

Example 1-mark solution: "Parallelism on a superscalar processor where multiple instructions are executed at once."
A 2-mark solution also indicates that "ILP exists when there is no dependency between instructions (or that dependency is broken)."

 b. temporal locality

Example 1-mark solution: "Chance for improved cache performance because of temporal proximity."
A 2-mark solution also indicates that "Temporal proximity means the same data element is accessed multiple times in a short time span so that the cache line has not yet been evicted from cache."

 c. spatial locality

Example 1-mark solution: "Chance for improved cache performance because of spatial proximity."
A 2-mark solution also indicates that "Spatial proximity means that data elements that are accessed one-after-the-other are also at a small address offset from each other, possibly even on the same or consecutive cache lines."

 d. L2 cache stall

Example 1-mark solution: "A processor stall due to L2 cache."
A 2-mark solution also indicates that "A stall occurs when the processor idles for a cycle because resources are unavailable."

 e. the "memory wall"

Example 1-mark solution: "The fact that (for the foreseeable future) the cost of memory accesses typically dwarfs that of computation."
A 2-mark solution also indicates that "This is a result of front-end/compute latencies being much smaller than back-end/memory latencies"


Q2) Somebody else in your "pod" asks you to review the following code and claims that it is "memory-bound." How would you verify or refute their claim? [The more precise that you are, the more marks you will receive (assuming the precision is also correct!).]  (3 marks)

// code snippet

1 mark: clear from response that student understands this question is about profiling
1 mark for indicating how to confirm there isn't another explanation, e.g.:
 * explicit reference to Intel top-down methodology to isolate that this is, in fact, stalling, and not to do, e.g., bad speculation
 * measurement of CPI to confirm that the program is stalled/has low compute-throughput
1 mark for indicating how to verify that the latencies are due to memory, e.g.,:
 * explicit mention of measuring L1/L2/L3 cache misses/stalls ratios
 * explicit mention of counting number of accesses to L2/L3


Q3) The following code finds the duplicate value in a list. How would you improve its cache performance (and thus efficiency)? [The more precise that you are, the more marks you will receive (assuming the precision is also correct!).] Justify your response. (3 marks)

// code snippet

1 mark: clear attempt/suggestion to improve *temporal* locality
1 mark: clear attempt/suggestion to achieve that via tiling
1 mark: very close attempt to demonstrate (e.g., pseudocode or c++) how to achieve the tiling correctly


Q4) Assume that a student is recorded by their id (6 digits), age, gpa (9-point scale), subject (from an enum of 16 possibilities), and gender (a float between 0 (M) and 1 (F)). From a list of students, you are to print out all details of the youngest one that is studying CS and has a GPA > 7.0.

// continued

(6 marks)

3 marks: decomposing AOS into SOA correctly
  - or 1-2 mark for a clear indication in that direction
1 mark: packing the struct(s) well, i.e., by choice and order of member variables/fields
  - or 1 mark for a clear indication in that direction
2 marks: adequate explanation for how this improves spatial locality and/or decreases working set size

* 1 bonus mark possible if pre-sorting the data (i.e., improving branch prediction) is described in a balanced manner that also indicates the trade-off.


Q5) Assume that everybody has a nemesis, i.e., that a person is defined as:

// continued

(6 marks)

2 marks: reallocating data contiguously as one array rather than arbitrarily on the heap
  - or 1 mark if talks about reducing working set size 
2 marks: storing data in access order, i.e., so that the pointers all move ahead (minimally if possible)
  - or 1 mark if talks about subsequent accesses being close
2 marks: if applies SOA decomposition to separate names and pointers into separate arrays


