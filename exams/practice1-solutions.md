# Practice Midterm 1 - Solutions

Q1) Please explain the following concepts in 1-3 sentences (2 marks each):

The responses do not need to be elaborate or dictionary-like. 1 mark is awarded if the response indicates a general sense of the concept. 2 marks are awarded if the response is fairly precise.

 a. instruction-level parallelism

Example 1-mark solution: "Parallelism on a superscalar processor where multiple instructions are executed at once."
A 2-mark solution also indicates that "ILP exists when there is no dependency between instructions (or that dependency is broken)."

 b. temporal locality

Example 1-mark solution: "Chance for improved cache performance because of temporal proximity."
A 2-mark solution also indicates that "Temporal proximity means the same data element is accessed multiple times in a short time span so that the cache line has not yet been evicted from cache."

 c. spatial locality

Example 1-mark solution: "Chance for improved cache performance because of spatial proximity."
A 2-mark solution also indicates that "Spatial proximity means that data elements that are accessed one-after-the-other are also at a small address offset from each other, possibly even on the same or consecutive cache lines."

 d. L2 cache stall

Example 1-mark solution: "A processor stall due to L2 cache."
A 2-mark solution also indicates that "A stall occurs when the processor idles for a cycle because resources are unavailable."

 e. the "memory wall"

Example 1-mark solution: "The fact that (for the foreseeable future) the cost of memory accesses typically dwarfs that of computation."
A 2-mark solution also indicates that "This is a result of front-end/compute latencies being much smaller than back-end/memory latencies"


Q2) Somebody else in your "pod" asks you to review the following code and claims that it is "memory-bound." How would you verify or refute their claim? [The more precise that you are, the more marks you will receive (assuming the precision is also correct!).]  (3 marks)

// code snippet

1 mark: clear from response that student understands this question is about profiling
1 mark for indicating how to confirm there isn't another explanation, e.g.:
 * explicit reference to Intel top-down methodology to isolate that this is, in fact, stalling, and not to do, e.g., bad speculation
 * measurement of CPI to confirm that the program is stalled/has low compute-throughput
1 mark for indicating how to verify that the latencies are due to memory, e.g.,:
 * explicit mention of measuring L1/L2/L3 cache misses/stalls ratios
 * explicit mention of counting number of accesses to L2/L3

Example solution worth 3 marks:
As per the Intel Top-down Analysis Method, it would be worth first confirming that the implementation is back-end bound. We could do this with hardware performance counters to first confirm that not all instructions are retiring and that the branch misprediction rate is very low (e.g., <2%). If this confirms that the implementation is, indeed, not suffering from bad speculation, we could then directly verify memory-boundedness by measuring the percentage of cycles that are stalled due to memory accesses.


Q3) The following code finds the duplicate value in a sorted list. How would you improve its cache performance (and thus efficiency)? [The more precise that you are, the more marks you will receive (assuming the precision is also correct!).] Justify your response. (3 marks)

// example solution code snippet (pseudocode would be fine)
```
#include <iostream>

float data[] = {...};

int main()
{
	size_t const n = sizeof( data ) / sizeof( float );
	auto const tile_size = 4;

	// TODO: handle boundary condition for arrays not divisible by tile_size
	for( int i = 0; i < n; i += tile_size )
	{
		for( int j = 0; j < n; ++j )
		{
			// tiling i improves temporal locality for outer loop
			for( int k = 0; k < tile_size; ++k )
			{
				if( data[ i + k ] == data[ j ] )
				{
					std::cout << data[ i + k ];
					return 0;
				}
			}
		}
	}

	std::cout << "No duplicates found! ðŸ˜¬" << std::endl;

	return 0;
}
```

1 mark: clear attempt/suggestion to improve *temporal* locality
1 mark: clear attempt/suggestion to achieve that via tiling
1 mark: very close attempt to demonstrate (e.g., pseudocode or c++) how to achieve the tiling correctly


Q4) Assume that a student is recorded by their id (6 digits), age, gpa (9-point scale), subject (from an enum of 16 possibilities), and gender (a float between 0 (M) and 1 (F)). From a list of students, you are to print out all details of the youngest one that is studying CS and has a GPA > 7.0.

// continued

(6 marks)

3 marks: decomposing AOS into SOA correctly
  - or 1-2 mark for a clear indication in that direction
1 mark: packing the struct(s) well, i.e., by choice and order of member variables/fields
  - or 1 mark for a clear indication in that direction
2 marks: adequate explanation for how this improves spatial locality and/or decreases working set size

* 1 bonus mark possible if pre-sorting the data (i.e., improving branch prediction) is described in a balanced manner that also indicates the trade-off.


// Example solution worth 6 marks (several alternatives exist)
```
enum class subjects : uint8_t { ... };

// note subject and age first for alignment
// despite subject and gpa being hotter than age
// (i.e., age is only relevant if subject and gpa match predicate)
struct hot_data
{
	subjects subject;
	uint8_t age;
	float gpa;
};

struct cold_data
{
	// packs student number into first 31 bits, uses the last bit for gender
	uint32_t data;
};

struct students_soa
{
	std::vector< hot_data > hot;
	std::vector< cold_data > cold;
}

// This is more efficient than an aos approach because the cold data is only
// relevant for printing out the final solution; i.e., loading it would increase
// our working set size unnecessarily. Individual structs are designed to be as
// small as possible by taking into account alignment (hot_data) and by packing field (cold_data)
```

Q5) Assume that everybody has a nemesis, i.e., that a person is defined as:

// continued

(6 marks)

2 marks: reallocating data contiguously as one array rather than arbitrarily on the heap
  - or 1 mark if talks about reducing working set size 
2 marks: storing data in access order, i.e., so that the pointers all move ahead (minimally if possible)
  - or 1 mark if talks about subsequent accesses being close
2 marks: if applies SOA decomposition to separate names and pointers into separate arrays


**Note** that this question is underspecified (unintentionally) and that would be taken into account when grading.

Example solution:

The data should be allocated as follows (given _n_) to ensure that it is contiguous:
```
struct people
{
	std::vector< person > people_list( n );
};
```

Let us assume the following algorithm to solve the problem:
```
bool has_loop()
{
	std::vector< bool > visited( n, false );
	for( person *p = &people_list[ 0 ]; p != NULL; p = p->next; )
	{
		if( visited[ p - &people_list[ 0 ] ] )
		{
			return true;
		}
		else
		{
			visited[ p - &people_list[ 0 ] ] = true;
		}
	}
	return false;
}
```

The data should be sorted such that `people_list[ i + 1 ]` = `people_list[ i ].next`
