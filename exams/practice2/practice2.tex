\documentclass[addpoints,12pt]{exam}

%\usepackage{newtxtext,newtxmath} % times new roman font
\usepackage{url}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}

\usepackage{bm,mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}

\usepackage{tikz,pgfplots}
\usetikzlibrary{shapes}

\usepackage{titling}
\setlength{\droptitle}{-6em}

\title{Practice Exam \#2\\[0.25em]
\large CSC 485C/586C: Data Management on Modern Computer Architectures}
\date{}

\begin{document}
\maketitle

\vspace{-6.5em}
{\centering
  \hspace{0.05\textwidth}
  \parbox{0.6\textwidth}{%
    Name:\enspace\hrulefill
  }\hspace{2em}
  \parbox{0.25\textwidth}{%
    V00\enspace\hrulefill
  }
}

\bigskip
%\printanswers
\begin{questions}
 \question Please explain the following concepts in 1-3 sentences and/or code snippets and/or a small illustration.  An excellent answer does not have to be long, just precise.\\{\em Guide: 2 minutes each} 

 \medskip
 
 \begin{parts}
   \part[1] Cache Coherency
     \begin{solution}[6em]
     \end{solution}
   
   \part[1] Data-level Parallelism
     \begin{solution}[6em]
     \end{solution}
   
   \part[1] False Sharing
     \begin{solution}[6em]
     \end{solution}
   
   \part[1] Synchronisation
     \begin{solution}[6em]
     \end{solution}
   
   \part[1] Vectorisation
     \begin{solution}[6em]
     \end{solution}
 \end{parts}
 
 \newpage
 \question The plot below shows the relative performance (as measured in execution time) of two parallel algorithms (called "My Algorithm" and "State of the Art") and a sequential baseline ("Seq. Baseline") on a fixed input. It is a {\em parallel scalability plot} that illustrates how performance changes as the number of threads varies, although it shows time rather than speed-up.
Answer the following questions that analyse this figure:\\
{\em Guide: 10 min total}

\begin{figure}[h!]
  \centering
  \input{tikz/work-eff-chart}
\end{figure}

   \begin{parts}
       \part[2] Which parallel algorithm is more work-efficient? Explain how you arrived at this conclusion.
           \begin{solution}[8em]
           \end{solution}

       \part[2] Which algorithm exhibits the best parallel scalability? Justify your response.
           \begin{solution}[8em]
           \end{solution}

       \part[2] What is the overall message (a.k.a., purpose, or significance) of the plot?
           \begin{solution}[8em]
           \end{solution}
   \end{parts}
 
 
  \question[8] Describe how you would vectorise/SIMD'ise the code below. Pseudocode or annotations is fine; proper syntax is not evaluated, so long as the intent is clear.\\
{\em Guide: 15 min}
  
   \bigskip
    \begin{minipage}{.35\textwidth}
      \begin{verbatim}
struct point
{
  double x;
  double y;
  double z;
};

std::vector< point > points;
      \end{verbatim}
    \end{minipage}
    \hfill
    \begin{minipage}{.55\textwidth}
      \begin{verbatim}
template < typename T >
auto num_matches( T const& points)
{
    auto const n = cards.size();
    auto num_matches = 0llu;

    for( auto i = 0u; i < n; ++i )
    {
        for( auto j = i + 1; j < n; ++j )
        {
            if( points[ i ].x == points[ j ].x
             && points[ i ].y == points[ j ].y )
                ++num_matches;
        }
    }
    return num_matches;
};
      \end{verbatim}
    \end{minipage}
    

      \begin{solution}[25em]
      \end{solution}
    
    \newpage
    \question You are given a set of randomly located unit (i.e., of size $1\times1$) squares in the Euclidean plane and are to determine how many of them intersect each other. Please write a work-efficient algorithm that scales well with parallelism to solve this task. It should do less work than the naive quadratic solution that compares every point to every other point.

Your best strategy will be to create a two-step algorithm. In the first step, you should preprocess the data. In the second step you should operate on the preprocessed data to solve the problem efficiently.

The focus of this question is on how you expose parallelism. You are free to describe the algorithm however you want (e.g., pseudocode, c++, a mixture thereof), but it should be specific enough that it is clear what are the distinct parallel tasks and what synchronisation and/or contention occurs.\\
{\em Guide: 20 min}

      \begin{solution}[8em]
      \end{solution}
\end{questions}

\vfill
\begin{minipage}{.2\textwidth}\hphantom{xxxxxxxxxxx}\end{minipage}
\gradetable[h][questions]

\end{document}
